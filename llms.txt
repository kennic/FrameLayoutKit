Repository: kennic/framelayoutkit
Files analyzed: 50

Estimated tokens: 60.8k

Directory structure:
└── kennic-framelayoutkit/
    ├── README.md
    ├── FrameLayoutKit.podspec
    ├── LICENSE
    ├── Package.swift
    ├── _Pods.xcodeproj -> Pods.xcodeproj
    ├── Example/
    │   ├── Podfile
    │   ├── Podfile.lock
    │   ├── FrameLayoutKit/
    │   │   ├── AppDelegate.swift
    │   │   ├── CardView.swift
    │   │   ├── FrameLayoutKit_Example.entitlements
    │   │   ├── Info.plist
    │   │   ├── NumberPadView.swift
    │   │   ├── TagListView.swift
    │   │   ├── ViewController.swift
    │   │   ├── Base.lproj/
    │   │   │   ├── LaunchScreen.xib
    │   │   │   └── Main.storyboard
    │   │   └── Images.xcassets/
    │   │       ├── Contents.json
    │   │       ├── AppIcon.appiconset/
    │   │       │   └── Contents.json
    │   │       ├── collapse_24x24.imageset/
    │   │       │   └── Contents.json
    │   │       ├── earth_48x48.imageset/
    │   │       │   └── Contents.json
    │   │       ├── expand_24x24.imageset/
    │   │       │   └── Contents.json
    │   │       └── rocket_32x32.imageset/
    │   │           └── Contents.json
    │   ├── FrameLayoutKit.xcodeproj/
    │   │   ├── project.pbxproj
    │   │   ├── project.xcworkspace/
    │   │   │   ├── contents.xcworkspacedata
    │   │   │   └── xcshareddata/
    │   │   │       └── IDEWorkspaceChecks.plist
    │   │   └── xcshareddata/
    │   │       └── xcschemes/
    │   │           └── FrameLayoutKit-Example.xcscheme
    │   └── FrameLayoutKit.xcworkspace/
    │       ├── contents.xcworkspacedata
    │       ├── xcshareddata/
    │       │   ├── IDEWorkspaceChecks.plist
    │       │   └── WorkspaceSettings.xcsettings
    │       └── xcuserdata/
    │           └── namkennic.xcuserdatad/
    │               ├── WorkspaceSettings.xcsettings
    │               └── xcdebugger/
    │                   └── Breakpoints_v2.xcbkptlist
    ├── FrameLayoutKit/
    │   └── Classes/
    │       ├── DoubleFrameLayout.swift
    │       ├── FlowFrameLayout.swift
    │       ├── FLSkeletonView.swift
    │       ├── FLView.swift
    │       ├── FrameLayout.swift
    │       ├── GridFrameLayout.swift
    │       ├── ScrollStackView.swift
    │       ├── StackFrameLayout.swift
    │       ├── .gitkeep
    │       └── Extensions/
    │           ├── DoubleFrameLayout+Chainable.swift
    │           ├── FlowFrameLayout+Chainable.swift
    │           ├── FrameLayout+Chainable.swift
    │           ├── FrameLayout+Extension.swift
    │           ├── GridFrameLayout+Chainable.swift
    │           ├── ScrollStackView+Chainable.swift
    │           ├── StackFrameLayout+Chainable.swift
    │           └── StackFrameLayout+DSL.swift
    ├── images/
    └── .swiftpm/
        └── xcode/
            ├── package.xcworkspace/
            │   └── contents.xcworkspacedata
            └── xcuserdata/
                └── namkennic.xcuserdatad/
                    └── xcschemes/
                        └── xcschememanagement.plist


================================================
FILE: README.md
================================================
# FrameLayoutKit

[![Platform](https://img.shields.io/cocoapods/p/FrameLayoutKit.svg?style=flat)](http://cocoapods.org/pods/FrameLayoutKit)
[![Language](http://img.shields.io/badge/language-Swift-brightgreen.svg?style=flat)](https://developer.apple.com/swift)
[![Version](https://img.shields.io/cocoapods/v/FrameLayoutKit.svg?style=flat-square)](http://cocoapods.org/pods/FrameLayoutKit)
[![SwiftPM Compatible](https://img.shields.io/badge/Swift%20Package%20Manager-compatible-brightgreen.svg)](https://github.com/apple/swift-package-manager)
[![License](https://img.shields.io/cocoapods/l/FrameLayoutKit.svg?style=flat-square)](http://cocoapods.org/pods/FrameLayoutKit)

![image](images/banner.jpg)

A super fast and easy-to-use layout library for iOS. FrameLayoutKit supports complex layouts, including chaining and nesting layout with simple and intuitive operand syntax.

It simplifies the UI creation process, resulting in cleaner and more maintainable code.

## Why Use FrameLayoutKit?

Say NO to autolayout constraint nightmare:

<table>
<tr><td> Autolayout </td> <td> FrameLayoutKit </td></tr>
<tr>
<td>
<img alt="No" src="images/no_constraint.png">
</td>
<td>
<img alt="Yes!!!" src="images/frameLayoutSyntax.png">
</td>
</tr>
</table>

## Table of Contents

-   [Installation](#installation)
-   [Core Components](#core-components)
-   [Basic Usage](#basic-usage)
-   [DSL Syntax](#dsl-syntax)
-   [Examples](#examples)
-   [Performance](#performance)
-   [Requirements](#requirements)
-   [Author](#author)
-   [License](#license)

## Installation

FrameLayoutKit is available through `Swift Package Manager` (Recommended) and [CocoaPods](http://cocoapods.org):

Regardless of the method, make sure to import the framework into your project:

```swift
import FrameLayoutKit
```

### Swift Package Manager (Recommended)

[Swift Package Manager](https://swift.org/package-manager/) is recommended to install FrameLayoutKit.

1.  Click `File`
2.  `Add Packages...`
3.  Enter the git URL for FrameLayoutKit:

```swift
https://github.com/kennic/FrameLayoutKit.git
```

### CocoaPods

FrameLayoutKit can also be installed as a [CocoaPod](https://cocoapods.org/). To install, add the following line to your Podfile:

```ruby
pod "FrameLayoutKit"
```

## Core Components

![image](images/FrameLayoutKit.png)

FrameLayoutKit includes the following core components:

### FrameLayout

The most basic class, manages a single view and adjusts its size and position based on configured properties.

### StackFrameLayout

Manages multiple views in rows (horizontal) or columns (vertical), similar to `UIStackView` but with higher performance and more options.

-   **HStackLayout**: Horizontal layout
-   **VStackLayout**: Vertical layout
-   **ZStackLayout**: Stacked layout (z-index)

### GridFrameLayout

Arranges views in a grid, with customizable number of columns and rows.

### FlowFrameLayout

Arranges views in a flow, automatically wrapping to the next line when there's not enough space.

### DoubleFrameLayout

Manages two views with various layout options.

### ScrollStackView

Combines `UIScrollView` with `StackFrameLayout` to create a scrollview that can automatically layout its child views.

## Tutorial and Documentation:
[See Tutorial by Codebase2Tutorial (Recommended)](https://code2tutorial.com/tutorial/9a53c8b4-8655-4b7f-a43a-121377744541/index.md)

[Read full document by DeepWiki](https://deepwiki.com/kennic/FrameLayoutKit)

## Basic Usage

### Creating and Configuring Layouts

```swift
// Create a vertical layout
let vStackLayout = VStackLayout()
vStackLayout.spacing = 10
vStackLayout.distribution = .center
vStackLayout.padding(top: 20, left: 20, bottom: 20, right: 20)

// Add views to the layout
vStackLayout.add(view1)
vStackLayout.add(view2)
vStackLayout.add(view3)

// Add the layout to a parent view
parentView.addSubview(vStackLayout)

// Update the layout's frame
vStackLayout.frame = parentView.bounds
```

### Using Operator Syntax (Recommended)

FrameLayoutKit provides the `+` operator syntax to easily add views to layouts:

```swift
// Add a single view
vStackLayout + view1

// Add an array of views
vStackLayout + [view1, view2, view3]

// Add spacing
vStackLayout + 10 // Add 10pt spacing

// Add a child layout
vStackLayout + hStackLayout
```

### Configuring View Properties

```swift
// Configure alignment
(vStackLayout + view1).alignment = (.center, .fill)

// Configure fixed size
(vStackLayout + view2).fixedSize = CGSize(width: 100, height: 50)

// Add a flexible view (can expand)
(vStackLayout + view3).flexible()
```

### Chained Syntax (Recommended)

```swift
vStackLayout
    .distribution(.center)
    .spacing(16)
    .flexible()
    .fixedHeight(50)
    .aligns(.top, .center)
    .padding(top: 20, left: 20, bottom: 20, right: 20)
```

## DSL Syntax (Experimental)

FrameLayoutKit provides a DSL (Domain Specific Language) syntax similar to SwiftUI, making layout creation more intuitive and readable:

```swift
// Create VStackLayout with DSL syntax
let vStackLayout = VStackView {
    titleLabel
    descriptionLabel
    SpaceItem(20) // Add a 20pt space
    Item(actionButton).minWidth(120) // Customize the button's minimum width
}

// Create HStackLayout with DSL syntax
let hStackLayout = HStackView {
    StackItem(imageView).fixedSize(width: 50, height: 50)
    VStackView {
        titleLabel
        subtitleLabel
    }.spacing(5)
    FlexibleSpace() // Add flexible space
    StackItem(button).align(vertical: .center, horizontal: .right)
}
```

### Main DSL Components

-   **StackItem**: Wraps a view to add to a stack with additional options
-   **SpaceItem**: Adds fixed spacing
-   **FlexibleSpace**: Adds flexible spacing (can expand)
-   **Item**: Similar to StackItem but with more options

## Examples

Here are some examples of how FrameLayoutKit works:

<table>
<tr><td> Source </td> <td> Result </td></tr>
<tr>
<td>
	
```swift
let frameLayout = HStackLayout()
frameLayout + VStackLayout {
   ($0 + earthImageView).alignment = (.top, .center)
   ($0 + 0).flexible() // add a flexible space
   ($0 + rocketImageView).alignment = (.center, .center)
}
frameLayout + VStackLayout {
   $0 + [nameLabel, dateLabel] // add an array of views
   $0 + 10 // add a space with a minimum of 10 pixels
   $0 + messageLabel // add a single view
}.spacing(5.0)

frameLayout
.spacing(15)
.padding(top: 15, left: 15, bottom: 15, right: 15)
.debug(true) // show dashed lines to visualize the layout

````
</td>
<td>
<img alt="result 1" src="images/helloWorld.png">
</td>
</tr>
</table>

<table>
<tr><td> Source </td> <td> Result </td></tr>
<tr>
<td>

```swift
let frameLayout = VStackLayout {
  ($0 + imageView).flexible()
  $0 + VStackLayout {
     $0 + titleLabel
     $0 + ratingLabel
  }
}.padding(top: 12, left: 12, bottom: 12, right: 12)
 .distribution(.bottom)
 .spacing(5)
````

</td>
<td>
<img alt="result 1" src="images/example_1.png">
</td>
</tr>
</table>

<table>
<tr><td> Source </td> <td> Result </td></tr>
<tr>
<td>

```swift
let posterSize = CGSize(width: 100, height: 150)
let frameLayout = ZStackLayout()
frameLayout + backdropImageView
frameLayout + VStackLayout {
 $0 + HStackLayout {
  ($0 + posterImageView).fixedSize(posterSize)
    $0 + VStackLayout {
      $0 + titleLabel
      $0 + subtitleLabel
    }.padding(bottom: 5).flexible().distribution(.bottom)
  }.spacing(12).padding(top: 0, left: 12, bottom: 12, right: 12)
}.distribution(.bottom)
```

</td>
<td>
<img alt="result 2" src="images/example_2.png">
</td>
</tr>
</table>

<table>
<tr><td> Source </td> <td> Result </td></tr>
<tr>
<td>

```swift
let buttonSize = CGSize(width: 45, height: 45)
let cardView = VStackLayout()
  .spacing(10)
  .padding(top: 24, left: 24, bottom: 24, right: 24)

cardView + titleLabel
(cardView + emailField).minHeight = 50
(cardView + passwordField).minHeight = 50
(cardView + nextButton).fixedHeight = 45
(cardView + separateLine)
  .fixedContentHeight(1)
  .padding(top: 4, left: 0, bottom: 4, right: 40)
cardView + HStackLayout {
 ($0 + [facebookButton, googleButton, appleButton])
  .forEach { $0.fixedContentSize(buttonSize) }
}.distribution(.center).spacing(10)
```

</td>
<td>
<img alt="result 2" src="images/example_3.png">
</td>
</tr>
</table>

## Key Properties

### FrameLayout

-   **targetView**: The view managed by this layout
-   **edgeInsets**: Padding around the view
-   **contentAlignment**: Content alignment (top, center, bottom, left, right, fill, fit)
-   **Size & Content Size**:
    -   `minSize/maxSize`, `fixedSize`: Minimum/maximum/fixed size of the layout.
    -   `minContentSize/maxContentSize`, `fixedContentSize`: Minimum/maximum/fixed size of the `targetView`.
    -   `extendSize (extendWidth, extendHeight)`: Additional size for the `contentSize`.
    -   `heightRatio`: Defines height based on width.
    -   `isIntrinsicSizeEnabled`: Controls if `sizeThatFits` uses `targetView`'s intrinsic size.
-   **Flexibility & Layout Behavior**:
    -   `isFlexible`, `flexibleRatio`: For flexible layouts within a stack.
    -   `allowContentVerticalGrowing/Shrinking`, `allowContentHorizontalGrowing/Shrinking`: Controls how `targetView` adapts to `FrameLayout`'s bounds.
-   **View Hierarchy & State**:
    -   `parent`: The containing `FrameLayout`.
    -   `bindingViews`, `bindingEdgeInsets`, `lazyBindingViews`: For binding other views to `targetView`'s frame.
    -   `ignoreHiddenView`, `isEnabled`, `isEmpty`: Control layout behavior based on visibility and enabled state.
-   **Positioning**:
    -   `translationOffset (translationX, translationY)`: For manual position adjustments.
-   **Callbacks**:
    -   `willSizeThatFitsBlock`: A block that will be called before `sizeThatFits` is called.
    -   `willLayoutSubviewsBlock`: A block that will be called before `layoutSubviews` is called.
    -   `didLayoutSubviewsBlock`: A block that will be called after `layoutSubviews` has finished.
-   **Debugging**:
    -   `debug`, `debugColor`: For visualizing layout frames.
-   **Skeleton Mode**:
    -   `isSkeletonMode`, `skeletonView`, `skeletonColor`, `skeletonMinSize`, `skeletonMaxSize`: For displaying placeholder content.
-   **Performance**:
    -   `shouldCacheSize`: Caches `sizeThatFits` results.

### StackFrameLayout

-   **Core Layout & Distribution**:
    -   `axis`: Direction of the stack (vertical or horizontal). You can use `VStackLayout` (vertical axis), `HStackLayout` (horizontal axis).
    -   `distribution`: How child views are distributed and space is allocated (e.g., `top`, `center`, `bottom`, `left`, `right`, `fill`, `equal`, `split`).
    -   `spacing`: Space between child views.
    -   `isOverlapped`: Allows child views to overlap. `ZStackLayout` automatically sets this to `true`.
    -   `isJustified`, `justifyThreshold`: Enables even distribution of child views. `justifyThreshold` is the minimum remaining space required to trigger justification.
-   **Child Item Management**:
    -   `frameLayouts`: Array of child `FrameLayout`s.
    -   `numberOfFrameLayouts`: Get or set the number of child layouts.
    -   `firstFrameLayout`, `lastFrameLayout`: Access the first and last child layout.
    -   `frameLayout(at: Int)`, `frameLayout(with: UIView)`: Retrieve specific child layouts.
    -   `enumerate(_ block: (FrameLayout, Int, inout Bool) -> Void)`: Iterate over child layouts.
    -   *Item Management Methods*: Includes functions like `add()`, `insert()`, `removeFrameLayout()`, `removeAll()`, `replace()`, `addSpace()`, and `invert()` for managing child items.
    -   `setUserInteraction(enabled: Bool)`: Sets `isUserInteractionEnabled` for the stack and all its child layouts.
-   **Child Item Defaults & Property Propagation**:
    -   `minItemSize`, `maxItemSize`, `fixedItemSize`: Sets default min/max/fixed content size for all child `FrameLayout`s added to the stack.
    -   *Property Propagation*: Many common `FrameLayout` properties (e.g., `ignoreHiddenView`, `allowContent...Growing/Shrinking`, `debug`, `skeletonMode`, `clipsToBounds`, `shouldCacheSize`) when set on a `StackFrameLayout` are propagated to its child `FrameLayout`s.

## Performance

FrameLayoutKit is one of the fastest layout libraries.
![Benchmark Results](images/bechmark.png "Benchmark results")

See: [Layout libraries benchmark's project](https://github.com/layoutBox/LayoutFrameworkBenchmark)

## Requirements

-   iOS 11.0+
-   Swift 5.0+

## Author

Nam Kennic, namkennic@me.com

## License

FrameLayoutKit is available under the MIT license. See the LICENSE file for more info.



================================================
FILE: FrameLayoutKit.podspec
================================================
Pod::Spec.new do |s|
	s.name             = 'FrameLayoutKit'
	s.version          = '7.1.1'
	s.summary          = 'FrameLayoutKit is a super fast and easy to use layout kit'
	s.description      = <<-DESC
	FrameLayoutKit is a powerful Swift library designed to streamline the process of creating user interfaces. With its intuitive operator syntax and support for nested functions, developers can effortlessly construct complex UI layouts with minimal code. By leveraging the flexibility of operators, developers can easily position and arrange views within a container view, enabling precise control over the visual hierarchy. Additionally, the library offers a range of convenient functions for configuring view properties, such as setting dimensions, margins, and alignment. Whether you're building a simple screen or a complex interface, FrameLayoutKit simplifies the UI creation process, resulting in cleaner, more maintainable code.
	DESC
	
	s.homepage          = 'https://github.com/kennic/FrameLayoutKit'
	s.license           = { :type => 'MIT', :file => 'LICENSE' }
	s.author            = { 'Nam Kennic' => 'namkennic@me.com' }
	s.source            = { :git => 'https://github.com/kennic/FrameLayoutKit.git', :tag => s.version.to_s }
	s.social_media_url  = 'https://twitter.com/namkennic'
	s.platform          = :ios, "11.0"
#	s.platform          = :tvos, "11.0"
	s.ios.deployment_target = '11.0'
#	s.tvos.deployment_target = '11.0'
	s.swift_version 	= "5.8"
	s.source_files 		= 'FrameLayoutKit/Classes/**/*.*'
	
end



================================================
FILE: LICENSE
================================================
Copyright (c) 2018 Nam Kennic <namkennic@me.com>

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.



================================================
FILE: Package.swift
================================================
// swift-tools-version:5.1
// The swift-tools-version declares the minimum version of Swift required to build this package.

import PackageDescription

let package = Package(
    name: "FrameLayoutKit",
	platforms: [.iOS(.v9), .tvOS(.v9)],
    products: [
        .library(
            name: "FrameLayoutKit",
            targets: ["FrameLayoutKit"]),
    ],
    targets: [
        .target(
            name: "FrameLayoutKit",
			path: "FrameLayoutKit/Classes",
			exclude: ["Example"])
    ],
	swiftLanguageVersions: [.v5]
)



================================================
SYMLINK: _Pods.xcodeproj -> Pods.xcodeproj
================================================



================================================
FILE: Example/Podfile
================================================
use_frameworks!

target 'FrameLayoutKit_Example' do
  pod 'FrameLayoutKit', :path => '../'
end



================================================
FILE: Example/Podfile.lock
================================================
PODS:
  - FrameLayoutKit (6.2.0)

DEPENDENCIES:
  - FrameLayoutKit (from `../`)

EXTERNAL SOURCES:
  FrameLayoutKit:
    :path: "../"

SPEC CHECKSUMS:
  FrameLayoutKit: f320aa7b377d9e01ddbf69f29a840e197fec2f4d

PODFILE CHECKSUM: ac097e09a36888b120812ddf1779def87475dc02

COCOAPODS: 1.11.2



================================================
FILE: Example/FrameLayoutKit/AppDelegate.swift
================================================
//
//  AppDelegate.swift
//  FrameLayoutKit
//
//  Created by Nam Kennic on 07/12/2018.
//  Copyright (c) 2018 Nam Kennic. All rights reserved.
//

import UIKit

@UIApplicationMain
class AppDelegate: UIResponder, UIApplicationDelegate {

    var window: UIWindow?

}




================================================
FILE: Example/FrameLayoutKit/CardView.swift
================================================
//
//  CardView.swift
//  FrameLayoutKit_Example
//
//  Created by Nam Kennic on 5/8/20.
//  Copyright © 2020 CocoaPods. All rights reserved.
//

import UIKit
import FrameLayoutKit

class CardView: UIView {
	let earthImageView = UIImageView(image: UIImage(named: "earth_48x48"))
	let rocketImageView = UIImageView(image: UIImage(named: "rocket_32x32"))
	let nameLabel = UILabel()
	let titleLabel = UILabel()
	let dateLabel = UILabel()
	let messageLabel = UILabel()
	let expandButton = UIButton()
	let frameLayout = HStackLayout {
		$0.spacing = 15.0
		$0.padding(15)
	}
	let blueView = UIView()
	let redView = UIView()
	var messageFrameLayout: FrameLayout!
	
	var onSizeChanged: ((CardView) -> Void)?
	
	init() {
		super.init(frame: .zero)
		
		layer.backgroundColor = UIColor.white.cgColor
		layer.shadowColor = UIColor.black.withAlphaComponent(0.5).cgColor
		layer.shadowOffset = .zero
		layer.shadowRadius = 5
		layer.shadowOpacity = 0.6
		layer.masksToBounds = false
		
		blueView.backgroundColor = .systemBlue
		redView.backgroundColor = .systemRed
		
		expandButton.setImage(UIImage(named: "collapse_24x24"), for: .normal)
		expandButton.setImage(UIImage(named: "expand_24x24"), for: .selected)
		expandButton.addTarget(self, action: #selector(onButtonTap), for: .touchUpInside)
		
		nameLabel.font = .systemFont(ofSize: 18, weight: .bold)
		nameLabel.text = "John Appleseed"
		
		titleLabel.textAlignment = .center
		titleLabel.font = .systemFont(ofSize: 14, weight: .regular)
		titleLabel.text = "Admin"
		titleLabel.textColor = .white
		titleLabel.backgroundColor = .purple
		titleLabel.layer.cornerRadius = 4.0
		titleLabel.layer.masksToBounds = true
		
		dateLabel.font = .systemFont(ofSize: 15, weight: .thin)
		dateLabel.text = "\(Date())"
		
		messageLabel.font = .systemFont(ofSize: 18, weight: .regular)
		messageLabel.text = "Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum"
		
		[nameLabel, dateLabel, messageLabel].forEach {
			$0.numberOfLines = 0
			$0.textColor = .black
		}
		
		[blueView, redView, earthImageView, rocketImageView, nameLabel, titleLabel, dateLabel, messageLabel, expandButton, frameLayout].forEach { addSubview($0) }

		// DSL syntax:
		
		frameLayout + VStackView {
			StackItem(earthImageView).align(vertical: .top, horizontal: .center)
			FlexibleSpace(10)
			StackItem(rocketImageView).align(vertical: .center, horizontal: .center).bindFrame(to: redView)
		}.bindFrame(to: blueView)
		
		frameLayout + VStackView {
			HStackView {
				StackItem(nameLabel)
				StackItem(titleLabel)
				FlexibleSpace()
				StackItem(expandButton)
			}.spacing(10)
			dateLabel
			StackItem(messageLabel).assign(to: &messageFrameLayout)
			FlexibleSpace()
			HStackView {
				Label(.yellow)
				Label(.green)
				Label(.brown)
				Label(.systemPink)
				Label(.blue)
			}.each { layout, _, _ in
				layout.didLayoutSubviewsBlock = {
					guard let label = $0.targetView as? UILabel else { return }
					let size = $0.frame.size
					label.text = "\(size.width) x \(size.height)"
				}
			}.distribution(.split(ratio: [0.5, -1, -1, 0.3])).spacing(10)
		}.flexible().spacing(5)
		
		
		// Standard syntax:
/*
		frameLayout + VStackLayout {
			($0 + earthImageView).alignment = (.top, .center)
			($0 + 0).flexible()
			($0 + rocketImageView).align(vertical: .center, horizontal: .center).bindFrame(to: redView) // Example of binding views: redView will stick together with rocketImageView
			$0.bindFrame(to: blueView) // Example of binding views: blueView will stick together with this VStackLayout
		}
		frameLayout + VStackLayout {
			$0 + HStackLayout {
				($0 + nameLabel)//.flexible(ratio: 0.8) // takes 80% of flexible width, uncomment to try it
				($0 + titleLabel).extends(size: CGSize(width: 10, height: 0))
				($0 + 0).flexible()
				$0 + expandButton
				
				$0.spacing(10)
			}
			$0 + dateLabel
//			$0 + 10.0
			messageFrameLayout = ($0 + messageLabel)
			
			//--- Example of split(ratio) distribution ---
			($0 + 0.0).flexible()
			$0 + HStackLayout {
				$0.distribution = .split(ratio: [0.5, -1, -1, 0.3]) // -1 means auto
				$0.spacing = 10
				
				($0 + [Label(.yellow), Label(.green), Label(.brown), Label(.systemPink), Label(.blue)]).forEach {
					$0.didLayoutSubviewsBlock = { sender in
						if let label = sender.targetView as? UILabel {
							let size = sender.frame.size
							label.text = "\(size.width) x \(size.height)"
						}
					}
				}
			}
			//---
			
			$0.flexible()
			  .spacing(5)
		}
*/
		
//		frameLayout
//			.debug(true)
//			.isSkeletonMode(true)

		DispatchQueue.main.asyncAfter(deadline: .now() + 2.0) {
			self.frameLayout.isSkeletonMode(false)
		}
	}
	
	func Label(_ color: UIColor, _ text: String = " ") -> UILabel {
		let label = UILabel()
		label.textColor = .black
		label.backgroundColor = color
		label.text = text
		return label
	}
	
	required init?(coder aDecoder: NSCoder) {
		fatalError("init(coder:) has not been implemented")
	}
	
	override func sizeThatFits(_ size: CGSize) -> CGSize {
		return frameLayout.sizeThatFits(size)
	}
	
	override func layoutSubviews() {
		super.layoutSubviews()
		frameLayout.frame = bounds
	}
	
	@objc func onButtonTap() {
		messageFrameLayout.isEnabled.toggle()
		expandButton.isSelected = !messageFrameLayout.isEnabled
		UIView.animate(withDuration: 0.25) { self.messageLabel.alpha = self.messageFrameLayout.isEnabled ? 1.0 : 0.0 }
		
		setNeedsLayout()
		onSizeChanged?(self)
	}
	
}



================================================
FILE: Example/FrameLayoutKit/FrameLayoutKit_Example.entitlements
================================================
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>com.apple.security.app-sandbox</key>
	<true/>
	<key>com.apple.security.network.client</key>
	<true/>
</dict>
</plist>



================================================
FILE: Example/FrameLayoutKit/Info.plist
================================================
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>CFBundleDevelopmentRegion</key>
	<string>en</string>
	<key>CFBundleExecutable</key>
	<string>$(EXECUTABLE_NAME)</string>
	<key>CFBundleIdentifier</key>
	<string>$(PRODUCT_BUNDLE_IDENTIFIER)</string>
	<key>CFBundleInfoDictionaryVersion</key>
	<string>6.0</string>
	<key>CFBundleName</key>
	<string>$(PRODUCT_NAME)</string>
	<key>CFBundlePackageType</key>
	<string>APPL</string>
	<key>CFBundleShortVersionString</key>
	<string>1.0</string>
	<key>CFBundleSignature</key>
	<string>????</string>
	<key>CFBundleVersion</key>
	<string>1</string>
	<key>LSRequiresIPhoneOS</key>
	<true/>
	<key>UILaunchStoryboardName</key>
	<string>LaunchScreen</string>
	<key>UIMainStoryboardFile</key>
	<string>Main</string>
	<key>UIRequiredDeviceCapabilities</key>
	<array>
		<string>armv7</string>
	</array>
	<key>UISupportedInterfaceOrientations</key>
	<array>
		<string>UIInterfaceOrientationPortrait</string>
		<string>UIInterfaceOrientationLandscapeLeft</string>
		<string>UIInterfaceOrientationLandscapeRight</string>
	</array>
</dict>
</plist>



================================================
FILE: Example/FrameLayoutKit/NumberPadView.swift
================================================
//
//  NumberPadView.swift
//  FrameLayoutKit_Example
//
//  Created by Nam Kennic on 5/8/20.
//  Copyright © 2020 CocoaPods. All rights reserved.
//

import UIKit
import FrameLayoutKit

class NumberPadView: UIView {
	let frameLayout = GridFrameLayout(axis: .horizontal, column: 3, rows: 4)
	let titleMap = "1 2 3 4 5 6 7 8 9 * 0 #"
	let colors: [UIColor] = [.red, .green, .blue, .brown, .gray, .yellow, .magenta, .black, .orange, .purple]
	
	fileprivate func color(index: Int? = nil) -> UIColor {
		let finalIndex = (index ?? Int(arc4random())) % colors.count
		return colors[finalIndex].withAlphaComponent(0.4)
	}
	
	init() {
		super.init(frame: .zero)
		backgroundColor = UIColor.black.withAlphaComponent(0.1)
		
		let titles = titleMap.components(separatedBy: " ")
		var i = 0
		let buttons = titles.map { (title) -> UIButton in
			let button = UIButton()
			button.setTitle(title, for: .normal)
			button.backgroundColor = color(index: i)
			button.showsTouchWhenHighlighted = true
			button.titleLabel?.font = .systemFont(ofSize: 24, weight: .medium)
			i += 1
			return button
		}
		
		frameLayout.edgeInsets = UIEdgeInsets(top: 10, left: 10, bottom: 10, right: 10)
		frameLayout.horizontalSpacing = 5
		frameLayout.verticalSpacing = 5
//		frameLayout.minColumnWidth = 150
		frameLayout.minRowHeight = 100
		frameLayout.isAutoSize = false
		frameLayout.views = buttons
		frameLayout.isUserInteractionEnabled = true
		addSubview(frameLayout)
	}
	
	required init?(coder aDecoder: NSCoder) {
		fatalError("init(coder:) has not been implemented")
	}
	
	override func sizeThatFits(_ size: CGSize) -> CGSize {
		return frameLayout.sizeThatFits(size)
	}
	
	override func layoutSubviews() {
		super.layoutSubviews()
		frameLayout.frame = bounds
	}

}



================================================
FILE: Example/FrameLayoutKit/TagListView.swift
================================================
//
//  TagListView.swift
//  FrameLayoutKit_Example
//
//  Created by Nam Kennic on 11/18/20.
//  Copyright © 2020 CocoaPods. All rights reserved.
//

import UIKit
import FrameLayoutKit

class TagListView: UIView {
	let flowLayout = FlowFrameLayout(axis: .horizontal)
	let addButton = UIButton()
	let removeButton = UIButton()
	let frameLayout = VStackLayout().spacing(4.0)
	let colors: [UIColor] = [.red, .green, .blue, .brown, .yellow, .magenta, .black, .orange, .purple, .systemPink]
	
	var onChanged: ((TagListView) -> Void)?
	
	init() {
		super.init(frame: .zero)
		
		backgroundColor = .gray
		
		flowLayout
			.interitemSpacing(4)
			.lineSpacing(4)
			.padding(top: 4, left: 4, bottom: 4, right: 4)
			.distribution(.left)
		
		addButton.setTitle("Add Item", for: .normal)
		addButton.backgroundColor = .systemBlue
		addButton.addTarget(self, action: #selector(addItem), for: .touchUpInside)
		addButton.showsTouchWhenHighlighted = true
		
		removeButton.setTitle("Remove Item", for: .normal)
		removeButton.backgroundColor = .systemPink
		removeButton.addTarget(self, action: #selector(removeLastItem), for: .touchUpInside)
		removeButton.showsTouchWhenHighlighted = true
		
		addSubview(flowLayout)
		addSubview(addButton)
		addSubview(removeButton)
		addSubview(frameLayout)
		
		// Disable justified last stack
		flowLayout.onNewStackBlock = { (sender, layout) in
			sender.stacks.forEach {
				$0.isJustified = $0 != sender.lastStack
			}
		}
		
		frameLayout + flowLayout
		frameLayout + HStackLayout {
			$0 + [removeButton, addButton]
			
			$0.distribution(.equal)
			  .fixedSize(CGSize(width: 0, height: 50))
		}
	}
	
	required init?(coder: NSCoder) {
		fatalError("init(coder:) has not been implemented")
	}
	
	override func sizeThatFits(_ size: CGSize) -> CGSize {
		return frameLayout.sizeThatFits(size)
	}
	
	override func layoutSubviews() {
		super.layoutSubviews()
		frameLayout.frame = bounds
	}
	
	fileprivate func color(index: Int? = nil) -> UIColor {
		let finalIndex = (index ?? Int(arc4random())) % colors.count
		return colors[finalIndex].withAlphaComponent(0.4)
	}
	
	@objc func addItem() {
		let count = flowLayout.views.count
		let title = Int.random(in: 0..<3) > 1 ? Int.random(in: 0..<1_000_000_000_000) : Int.random(in: 0..<100)
		let tagButton = UIButton()
		tagButton.titleLabel?.font = .systemFont(ofSize: 20)
		tagButton.titleLabel?.adjustsFontSizeToFitWidth = false
		tagButton.titleLabel?.lineBreakMode = .byClipping
		tagButton.setTitle("  [\(count)]: \(title)  ", for: .normal)
		tagButton.setTitleColor(.white, for: .normal)
		tagButton.backgroundColor = color()
		tagButton.layer.cornerRadius = 5.0
		tagButton.layer.masksToBounds = true
		
		flowLayout + tagButton
		onChanged?(self)
	}
	
	@objc func removeLastItem() {
		guard let item = flowLayout.views.last else { return }
		item.removeFromSuperview()
		flowLayout.views.removeLast()		
		onChanged?(self)
	}
	
}



================================================
FILE: Example/FrameLayoutKit/ViewController.swift
================================================
//
//  ViewController.swift
//  FrameLayoutKit
//
//  Created by Nam Kennic on 07/12/2018.
//  Copyright (c) 2018 Nam Kennic. All rights reserved.
//

import UIKit
import FrameLayoutKit

class ViewController: UIViewController {
	let scrollStackView = ScrollStackView()
	let tagListView = TagListView()
	
    override func viewDidLoad() {
        super.viewDidLoad()
		
		view.backgroundColor = .lightGray
		
		var cardViews = [UIView]()
		for _ in 0..<5 {
			let cardView = CardView()
			cardView.onSizeChanged = { [weak self] sender in
				self?.scrollStackView.relayoutSubviews(animateDuration: 0.35)
			}
			cardViews.append(cardView)
		}
		
		tagListView.onChanged = { [weak self] sender in
			self?.scrollStackView.relayoutSubviews(animateDuration: 0.35)
		}
		
		scrollStackView + cardViews
		scrollStackView + NumberPadView()
		scrollStackView + tagListView
		
		scrollStackView
			.spacing(20)
			.padding(top: 50, left: 50, bottom: 50, right: 50)
			.distribution(.center)
		
		view.addSubview(scrollStackView)
    }
	
	override func viewDidLayoutSubviews() {
		super.viewDidLayoutSubviews()
		scrollStackView.frame = view.bounds
	}

}



================================================
FILE: Example/FrameLayoutKit/Base.lproj/LaunchScreen.xib
================================================
<?xml version="1.0" encoding="UTF-8"?>
<document type="com.apple.InterfaceBuilder3.CocoaTouch.XIB" version="3.0" toolsVersion="13771" targetRuntime="iOS.CocoaTouch" propertyAccessControl="none" useAutolayout="YES" launchScreen="YES" useTraitCollections="YES" colorMatched="YES">
    <device id="retina4_7" orientation="portrait">
        <adaptation id="fullscreen"/>
    </device>
    <dependencies>
        <deployment identifier="iOS"/>
        <plugIn identifier="com.apple.InterfaceBuilder.IBCocoaTouchPlugin" version="13772"/>
        <capability name="Constraints with non-1.0 multipliers" minToolsVersion="5.1"/>
        <capability name="documents saved in the Xcode 8 format" minToolsVersion="8.0"/>
    </dependencies>
    <objects>
        <placeholder placeholderIdentifier="IBFilesOwner" id="-1" userLabel="File's Owner"/>
        <placeholder placeholderIdentifier="IBFirstResponder" id="-2" customClass="UIResponder"/>
        <view contentMode="scaleToFill" id="iN0-l3-epB">
            <rect key="frame" x="0.0" y="0.0" width="480" height="480"/>
            <autoresizingMask key="autoresizingMask" widthSizable="YES" heightSizable="YES"/>
            <subviews>
                <label opaque="NO" clipsSubviews="YES" userInteractionEnabled="NO" contentMode="left" horizontalHuggingPriority="251" verticalHuggingPriority="251" text="  Copyright (c) 2015 CocoaPods. All rights reserved." textAlignment="center" lineBreakMode="tailTruncation" baselineAdjustment="alignBaselines" minimumFontSize="9" translatesAutoresizingMaskIntoConstraints="NO" id="8ie-xW-0ye">
                    <rect key="frame" x="20" y="439" width="441" height="21"/>
                    <fontDescription key="fontDescription" type="system" pointSize="17"/>
                    <color key="textColor" cocoaTouchSystemColor="darkTextColor"/>
                    <nil key="highlightedColor"/>
                </label>
                <label opaque="NO" clipsSubviews="YES" userInteractionEnabled="NO" contentMode="left" horizontalHuggingPriority="251" verticalHuggingPriority="251" text="FrameLayoutKit" textAlignment="center" lineBreakMode="middleTruncation" baselineAdjustment="alignBaselines" minimumFontSize="18" translatesAutoresizingMaskIntoConstraints="NO" id="kId-c2-rCX">
                    <rect key="frame" x="20" y="140" width="441" height="43"/>
                    <fontDescription key="fontDescription" type="boldSystem" pointSize="36"/>
                    <color key="textColor" cocoaTouchSystemColor="darkTextColor"/>
                    <nil key="highlightedColor"/>
                </label>
            </subviews>
            <color key="backgroundColor" red="1" green="1" blue="1" alpha="1" colorSpace="custom" customColorSpace="sRGB"/>
            <constraints>
                <constraint firstItem="kId-c2-rCX" firstAttribute="centerY" secondItem="iN0-l3-epB" secondAttribute="bottom" multiplier="1/3" constant="1" id="5cJ-9S-tgC"/>
                <constraint firstAttribute="centerX" secondItem="kId-c2-rCX" secondAttribute="centerX" id="Koa-jz-hwk"/>
                <constraint firstAttribute="bottom" secondItem="8ie-xW-0ye" secondAttribute="bottom" constant="20" id="Kzo-t9-V3l"/>
                <constraint firstItem="8ie-xW-0ye" firstAttribute="leading" secondItem="iN0-l3-epB" secondAttribute="leading" constant="20" symbolic="YES" id="MfP-vx-nX0"/>
                <constraint firstAttribute="centerX" secondItem="8ie-xW-0ye" secondAttribute="centerX" id="ZEH-qu-HZ9"/>
                <constraint firstItem="kId-c2-rCX" firstAttribute="leading" secondItem="iN0-l3-epB" secondAttribute="leading" constant="20" symbolic="YES" id="fvb-Df-36g"/>
            </constraints>
            <nil key="simulatedStatusBarMetrics"/>
            <freeformSimulatedSizeMetrics key="simulatedDestinationMetrics"/>
            <point key="canvasLocation" x="548" y="455"/>
        </view>
    </objects>
</document>



================================================
FILE: Example/FrameLayoutKit/Base.lproj/Main.storyboard
================================================
<?xml version="1.0" encoding="UTF-8"?>
<document type="com.apple.InterfaceBuilder3.CocoaTouch.Storyboard.XIB" version="3.0" toolsVersion="13771" targetRuntime="iOS.CocoaTouch" propertyAccessControl="none" useAutolayout="YES" useTraitCollections="YES" colorMatched="YES" initialViewController="vXZ-lx-hvc">
    <device id="retina4_7" orientation="portrait">
        <adaptation id="fullscreen"/>
    </device>
    <dependencies>
        <deployment identifier="iOS"/>
        <plugIn identifier="com.apple.InterfaceBuilder.IBCocoaTouchPlugin" version="13772"/>
        <capability name="documents saved in the Xcode 8 format" minToolsVersion="8.0"/>
    </dependencies>
    <scenes>
        <!--View Controller-->
        <scene sceneID="ufC-wZ-h7g">
            <objects>
                <viewController id="vXZ-lx-hvc" customClass="ViewController" customModule="FrameLayoutKit_Example" customModuleProvider="target" sceneMemberID="viewController">
                    <layoutGuides>
                        <viewControllerLayoutGuide type="top" id="jyV-Pf-zRb"/>
                        <viewControllerLayoutGuide type="bottom" id="2fi-mo-0CV"/>
                    </layoutGuides>
                    <view key="view" contentMode="scaleToFill" id="kh9-bI-dsS">
                        <rect key="frame" x="0.0" y="0.0" width="375" height="667"/>
                        <autoresizingMask key="autoresizingMask" flexibleMaxX="YES" flexibleMaxY="YES"/>
                        <color key="backgroundColor" red="1" green="1" blue="1" alpha="1" colorSpace="custom" customColorSpace="sRGB"/>
                    </view>
                </viewController>
                <placeholder placeholderIdentifier="IBFirstResponder" id="x5A-6p-PRh" sceneMemberID="firstResponder"/>
            </objects>
        </scene>
    </scenes>
</document>



================================================
FILE: Example/FrameLayoutKit/Images.xcassets/Contents.json
================================================
{
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}



================================================
FILE: Example/FrameLayoutKit/Images.xcassets/AppIcon.appiconset/Contents.json
================================================
{
  "images" : [
    {
      "idiom" : "iphone",
      "size" : "20x20",
      "scale" : "2x"
    },
    {
      "idiom" : "iphone",
      "size" : "20x20",
      "scale" : "3x"
    },
    {
      "idiom" : "iphone",
      "size" : "29x29",
      "scale" : "2x"
    },
    {
      "idiom" : "iphone",
      "size" : "29x29",
      "scale" : "3x"
    },
    {
      "idiom" : "iphone",
      "size" : "40x40",
      "scale" : "2x"
    },
    {
      "idiom" : "iphone",
      "size" : "40x40",
      "scale" : "3x"
    },
    {
      "idiom" : "iphone",
      "size" : "60x60",
      "scale" : "2x"
    },
    {
      "idiom" : "iphone",
      "size" : "60x60",
      "scale" : "3x"
    },
    {
      "idiom" : "ios-marketing",
      "size" : "1024x1024",
      "scale" : "1x"
    }
  ],
  "info" : {
    "version" : 1,
    "author" : "xcode"
  }
}



================================================
FILE: Example/FrameLayoutKit/Images.xcassets/collapse_24x24.imageset/Contents.json
================================================
{
  "images" : [
    {
      "filename" : "collapse_24x24@1x.png",
      "idiom" : "universal",
      "scale" : "1x"
    },
    {
      "filename" : "collapse_24x24@2x.png",
      "idiom" : "universal",
      "scale" : "2x"
    },
    {
      "filename" : "collapse_24x24@3x.png",
      "idiom" : "universal",
      "scale" : "3x"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}



================================================
FILE: Example/FrameLayoutKit/Images.xcassets/earth_48x48.imageset/Contents.json
================================================
{
  "images" : [
    {
      "idiom" : "universal",
      "filename" : "earth_48x48@1x.png",
      "scale" : "1x"
    },
    {
      "idiom" : "universal",
      "filename" : "earth_48x48@2x.png",
      "scale" : "2x"
    },
    {
      "idiom" : "universal",
      "filename" : "earth_48x48@3x.png",
      "scale" : "3x"
    }
  ],
  "info" : {
    "version" : 1,
    "author" : "xcode"
  }
}


================================================
FILE: Example/FrameLayoutKit/Images.xcassets/expand_24x24.imageset/Contents.json
================================================
{
  "images" : [
    {
      "filename" : "expand_24x24@1x.png",
      "idiom" : "universal",
      "scale" : "1x"
    },
    {
      "filename" : "expand_24x24@2x.png",
      "idiom" : "universal",
      "scale" : "2x"
    },
    {
      "filename" : "expand_24x24@3x.png",
      "idiom" : "universal",
      "scale" : "3x"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}



================================================
FILE: Example/FrameLayoutKit/Images.xcassets/rocket_32x32.imageset/Contents.json
================================================
{
  "images" : [
    {
      "filename" : "rocket_32x32@1x.png",
      "idiom" : "universal",
      "scale" : "1x"
    },
    {
      "filename" : "rocket_32x32@2x.png",
      "idiom" : "universal",
      "scale" : "2x"
    },
    {
      "filename" : "rocket_32x32@3x.png",
      "idiom" : "universal",
      "scale" : "3x"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}



================================================
FILE: Example/FrameLayoutKit.xcodeproj/project.pbxproj
================================================
// !$*UTF8*$!
{
	archiveVersion = 1;
	classes = {
	};
	objectVersion = 46;
	objects = {

/* Begin PBXBuildFile section */
		607FACD61AFB9204008FA782 /* AppDelegate.swift in Sources */ = {isa = PBXBuildFile; fileRef = 607FACD51AFB9204008FA782 /* AppDelegate.swift */; };
		607FACD81AFB9204008FA782 /* ViewController.swift in Sources */ = {isa = PBXBuildFile; fileRef = 607FACD71AFB9204008FA782 /* ViewController.swift */; };
		607FACDB1AFB9204008FA782 /* Main.storyboard in Resources */ = {isa = PBXBuildFile; fileRef = 607FACD91AFB9204008FA782 /* Main.storyboard */; };
		607FACDD1AFB9204008FA782 /* Images.xcassets in Resources */ = {isa = PBXBuildFile; fileRef = 607FACDC1AFB9204008FA782 /* Images.xcassets */; };
		607FACE01AFB9204008FA782 /* LaunchScreen.xib in Resources */ = {isa = PBXBuildFile; fileRef = 607FACDE1AFB9204008FA782 /* LaunchScreen.xib */; };
		632A5FA524651ACB008DD793 /* CardView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 632A5FA424651ACB008DD793 /* CardView.swift */; };
		632A5FA724651B14008DD793 /* NumberPadView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 632A5FA624651B14008DD793 /* NumberPadView.swift */; };
		635B4D7F256530B70006C5B8 /* TagListView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 635B4D7E256530B70006C5B8 /* TagListView.swift */; };
		B0779CC809BA3EBEA8A7BA24 /* Pods_FrameLayoutKit_Example.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 88079A93676318D377A9E051 /* Pods_FrameLayoutKit_Example.framework */; };
/* End PBXBuildFile section */

/* Begin PBXFileReference section */
		23024746510C90D82DBB9804 /* Pods-FrameLayoutKit_Example.debug.xcconfig */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.xcconfig; name = "Pods-FrameLayoutKit_Example.debug.xcconfig"; path = "Target Support Files/Pods-FrameLayoutKit_Example/Pods-FrameLayoutKit_Example.debug.xcconfig"; sourceTree = "<group>"; };
		56C814E0EDE5EC3DE2FA2FE4 /* LICENSE */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text; name = LICENSE; path = ../LICENSE; sourceTree = "<group>"; };
		5B2624AAEE48DCD02D4F0B67 /* README.md */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = net.daringfireball.markdown; name = README.md; path = ../README.md; sourceTree = "<group>"; };
		607FACD01AFB9204008FA782 /* FrameLayoutKit_Example.app */ = {isa = PBXFileReference; explicitFileType = wrapper.application; includeInIndex = 0; path = FrameLayoutKit_Example.app; sourceTree = BUILT_PRODUCTS_DIR; };
		607FACD41AFB9204008FA782 /* Info.plist */ = {isa = PBXFileReference; lastKnownFileType = text.plist.xml; path = Info.plist; sourceTree = "<group>"; };
		607FACD51AFB9204008FA782 /* AppDelegate.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = AppDelegate.swift; sourceTree = "<group>"; };
		607FACD71AFB9204008FA782 /* ViewController.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = ViewController.swift; sourceTree = "<group>"; };
		607FACDA1AFB9204008FA782 /* Base */ = {isa = PBXFileReference; lastKnownFileType = file.storyboard; name = Base; path = Base.lproj/Main.storyboard; sourceTree = "<group>"; };
		607FACDC1AFB9204008FA782 /* Images.xcassets */ = {isa = PBXFileReference; lastKnownFileType = folder.assetcatalog; path = Images.xcassets; sourceTree = "<group>"; };
		607FACDF1AFB9204008FA782 /* Base */ = {isa = PBXFileReference; lastKnownFileType = file.xib; name = Base; path = Base.lproj/LaunchScreen.xib; sourceTree = "<group>"; };
		632A5FA424651ACB008DD793 /* CardView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = CardView.swift; sourceTree = "<group>"; };
		632A5FA624651B14008DD793 /* NumberPadView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = NumberPadView.swift; sourceTree = "<group>"; };
		635B4D7E256530B70006C5B8 /* TagListView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = TagListView.swift; sourceTree = "<group>"; };
		6369D7AB2430D68E00C60584 /* FrameLayoutKit_Example.entitlements */ = {isa = PBXFileReference; lastKnownFileType = text.plist.entitlements; path = FrameLayoutKit_Example.entitlements; sourceTree = "<group>"; };
		88079A93676318D377A9E051 /* Pods_FrameLayoutKit_Example.framework */ = {isa = PBXFileReference; explicitFileType = wrapper.framework; includeInIndex = 0; path = Pods_FrameLayoutKit_Example.framework; sourceTree = BUILT_PRODUCTS_DIR; };
		8A9D6655F23A4A71202D1A3A /* Pods-FrameLayoutKit_Tests.debug.xcconfig */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.xcconfig; name = "Pods-FrameLayoutKit_Tests.debug.xcconfig"; path = "Target Support Files/Pods-FrameLayoutKit_Tests/Pods-FrameLayoutKit_Tests.debug.xcconfig"; sourceTree = "<group>"; };
		8EDFCE92FF181156BE7A04B8 /* Pods_FrameLayoutKit_Tests.framework */ = {isa = PBXFileReference; explicitFileType = wrapper.framework; includeInIndex = 0; path = Pods_FrameLayoutKit_Tests.framework; sourceTree = BUILT_PRODUCTS_DIR; };
		AB5553AC3A0BA7787C1FD21B /* Pods-FrameLayoutKit_Example.release.xcconfig */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.xcconfig; name = "Pods-FrameLayoutKit_Example.release.xcconfig"; path = "Target Support Files/Pods-FrameLayoutKit_Example/Pods-FrameLayoutKit_Example.release.xcconfig"; sourceTree = "<group>"; };
		B4FB4222A4679285B6F26B60 /* FrameLayoutKit.podspec */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text; name = FrameLayoutKit.podspec; path = ../FrameLayoutKit.podspec; sourceTree = "<group>"; xcLanguageSpecificationIdentifier = xcode.lang.ruby; };
		CC06034BECC9436AF0A3C901 /* Pods-FrameLayoutKit_Tests.release.xcconfig */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.xcconfig; name = "Pods-FrameLayoutKit_Tests.release.xcconfig"; path = "Target Support Files/Pods-FrameLayoutKit_Tests/Pods-FrameLayoutKit_Tests.release.xcconfig"; sourceTree = "<group>"; };
/* End PBXFileReference section */

/* Begin PBXFrameworksBuildPhase section */
		607FACCD1AFB9204008FA782 /* Frameworks */ = {
			isa = PBXFrameworksBuildPhase;
			buildActionMask = 2147483647;
			files = (
				B0779CC809BA3EBEA8A7BA24 /* Pods_FrameLayoutKit_Example.framework in Frameworks */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXFrameworksBuildPhase section */

/* Begin PBXGroup section */
		196EE48AEFF07E28138992B3 /* Pods */ = {
			isa = PBXGroup;
			children = (
				23024746510C90D82DBB9804 /* Pods-FrameLayoutKit_Example.debug.xcconfig */,
				AB5553AC3A0BA7787C1FD21B /* Pods-FrameLayoutKit_Example.release.xcconfig */,
				8A9D6655F23A4A71202D1A3A /* Pods-FrameLayoutKit_Tests.debug.xcconfig */,
				CC06034BECC9436AF0A3C901 /* Pods-FrameLayoutKit_Tests.release.xcconfig */,
			);
			path = Pods;
			sourceTree = "<group>";
		};
		607FACC71AFB9204008FA782 = {
			isa = PBXGroup;
			children = (
				607FACF51AFB993E008FA782 /* Podspec Metadata */,
				607FACD21AFB9204008FA782 /* Example for FrameLayoutKit */,
				607FACD11AFB9204008FA782 /* Products */,
				196EE48AEFF07E28138992B3 /* Pods */,
				AAFC5113C9041CD699372BFA /* Frameworks */,
			);
			sourceTree = "<group>";
		};
		607FACD11AFB9204008FA782 /* Products */ = {
			isa = PBXGroup;
			children = (
				607FACD01AFB9204008FA782 /* FrameLayoutKit_Example.app */,
			);
			name = Products;
			sourceTree = "<group>";
		};
		607FACD21AFB9204008FA782 /* Example for FrameLayoutKit */ = {
			isa = PBXGroup;
			children = (
				607FACD51AFB9204008FA782 /* AppDelegate.swift */,
				607FACD71AFB9204008FA782 /* ViewController.swift */,
				632A5FA424651ACB008DD793 /* CardView.swift */,
				632A5FA624651B14008DD793 /* NumberPadView.swift */,
				635B4D7E256530B70006C5B8 /* TagListView.swift */,
				607FACD91AFB9204008FA782 /* Main.storyboard */,
				607FACDC1AFB9204008FA782 /* Images.xcassets */,
				607FACDE1AFB9204008FA782 /* LaunchScreen.xib */,
				6369D7AB2430D68E00C60584 /* FrameLayoutKit_Example.entitlements */,
				607FACD31AFB9204008FA782 /* Supporting Files */,
			);
			name = "Example for FrameLayoutKit";
			path = FrameLayoutKit;
			sourceTree = "<group>";
		};
		607FACD31AFB9204008FA782 /* Supporting Files */ = {
			isa = PBXGroup;
			children = (
				607FACD41AFB9204008FA782 /* Info.plist */,
			);
			name = "Supporting Files";
			sourceTree = "<group>";
		};
		607FACF51AFB993E008FA782 /* Podspec Metadata */ = {
			isa = PBXGroup;
			children = (
				B4FB4222A4679285B6F26B60 /* FrameLayoutKit.podspec */,
				5B2624AAEE48DCD02D4F0B67 /* README.md */,
				56C814E0EDE5EC3DE2FA2FE4 /* LICENSE */,
			);
			name = "Podspec Metadata";
			sourceTree = "<group>";
		};
		AAFC5113C9041CD699372BFA /* Frameworks */ = {
			isa = PBXGroup;
			children = (
				88079A93676318D377A9E051 /* Pods_FrameLayoutKit_Example.framework */,
				8EDFCE92FF181156BE7A04B8 /* Pods_FrameLayoutKit_Tests.framework */,
			);
			name = Frameworks;
			sourceTree = "<group>";
		};
/* End PBXGroup section */

/* Begin PBXNativeTarget section */
		607FACCF1AFB9204008FA782 /* FrameLayoutKit_Example */ = {
			isa = PBXNativeTarget;
			buildConfigurationList = 607FACEF1AFB9204008FA782 /* Build configuration list for PBXNativeTarget "FrameLayoutKit_Example" */;
			buildPhases = (
				84B771FF5FFD4E26B6BC16D3 /* [CP] Check Pods Manifest.lock */,
				607FACCC1AFB9204008FA782 /* Sources */,
				607FACCD1AFB9204008FA782 /* Frameworks */,
				607FACCE1AFB9204008FA782 /* Resources */,
				34E235A52871F92793844191 /* [CP] Embed Pods Frameworks */,
			);
			buildRules = (
			);
			dependencies = (
			);
			name = FrameLayoutKit_Example;
			productName = FrameLayoutKit;
			productReference = 607FACD01AFB9204008FA782 /* FrameLayoutKit_Example.app */;
			productType = "com.apple.product-type.application";
		};
/* End PBXNativeTarget section */

/* Begin PBXProject section */
		607FACC81AFB9204008FA782 /* Project object */ = {
			isa = PBXProject;
			attributes = {
				LastSwiftUpdateCheck = 0830;
				LastUpgradeCheck = 0940;
				ORGANIZATIONNAME = CocoaPods;
				TargetAttributes = {
					607FACCF1AFB9204008FA782 = {
						CreatedOnToolsVersion = 6.3.1;
						DevelopmentTeam = 385YL4KG69;
						LastSwiftMigration = 0900;
					};
				};
			};
			buildConfigurationList = 607FACCB1AFB9204008FA782 /* Build configuration list for PBXProject "FrameLayoutKit" */;
			compatibilityVersion = "Xcode 3.2";
			developmentRegion = English;
			hasScannedForEncodings = 0;
			knownRegions = (
				English,
				en,
				Base,
			);
			mainGroup = 607FACC71AFB9204008FA782;
			productRefGroup = 607FACD11AFB9204008FA782 /* Products */;
			projectDirPath = "";
			projectRoot = "";
			targets = (
				607FACCF1AFB9204008FA782 /* FrameLayoutKit_Example */,
			);
		};
/* End PBXProject section */

/* Begin PBXResourcesBuildPhase section */
		607FACCE1AFB9204008FA782 /* Resources */ = {
			isa = PBXResourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
				607FACDB1AFB9204008FA782 /* Main.storyboard in Resources */,
				607FACE01AFB9204008FA782 /* LaunchScreen.xib in Resources */,
				607FACDD1AFB9204008FA782 /* Images.xcassets in Resources */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXResourcesBuildPhase section */

/* Begin PBXShellScriptBuildPhase section */
		34E235A52871F92793844191 /* [CP] Embed Pods Frameworks */ = {
			isa = PBXShellScriptBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			inputPaths = (
				"${PODS_ROOT}/Target Support Files/Pods-FrameLayoutKit_Example/Pods-FrameLayoutKit_Example-frameworks.sh",
				"${BUILT_PRODUCTS_DIR}/FrameLayoutKit/FrameLayoutKit.framework",
			);
			name = "[CP] Embed Pods Frameworks";
			outputPaths = (
				"${TARGET_BUILD_DIR}/${FRAMEWORKS_FOLDER_PATH}/FrameLayoutKit.framework",
			);
			runOnlyForDeploymentPostprocessing = 0;
			shellPath = /bin/sh;
			shellScript = "\"${PODS_ROOT}/Target Support Files/Pods-FrameLayoutKit_Example/Pods-FrameLayoutKit_Example-frameworks.sh\"\n";
			showEnvVarsInLog = 0;
		};
		84B771FF5FFD4E26B6BC16D3 /* [CP] Check Pods Manifest.lock */ = {
			isa = PBXShellScriptBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			inputFileListPaths = (
			);
			inputPaths = (
				"${PODS_PODFILE_DIR_PATH}/Podfile.lock",
				"${PODS_ROOT}/Manifest.lock",
			);
			name = "[CP] Check Pods Manifest.lock";
			outputFileListPaths = (
			);
			outputPaths = (
				"$(DERIVED_FILE_DIR)/Pods-FrameLayoutKit_Example-checkManifestLockResult.txt",
			);
			runOnlyForDeploymentPostprocessing = 0;
			shellPath = /bin/sh;
			shellScript = "diff \"${PODS_PODFILE_DIR_PATH}/Podfile.lock\" \"${PODS_ROOT}/Manifest.lock\" > /dev/null\nif [ $? != 0 ] ; then\n    # print error to STDERR\n    echo \"error: The sandbox is not in sync with the Podfile.lock. Run 'pod install' or update your CocoaPods installation.\" >&2\n    exit 1\nfi\n# This output is used by Xcode 'outputs' to avoid re-running this script phase.\necho \"SUCCESS\" > \"${SCRIPT_OUTPUT_FILE_0}\"\n";
			showEnvVarsInLog = 0;
		};
/* End PBXShellScriptBuildPhase section */

/* Begin PBXSourcesBuildPhase section */
		607FACCC1AFB9204008FA782 /* Sources */ = {
			isa = PBXSourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
				635B4D7F256530B70006C5B8 /* TagListView.swift in Sources */,
				607FACD81AFB9204008FA782 /* ViewController.swift in Sources */,
				632A5FA524651ACB008DD793 /* CardView.swift in Sources */,
				607FACD61AFB9204008FA782 /* AppDelegate.swift in Sources */,
				632A5FA724651B14008DD793 /* NumberPadView.swift in Sources */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXSourcesBuildPhase section */

/* Begin PBXVariantGroup section */
		607FACD91AFB9204008FA782 /* Main.storyboard */ = {
			isa = PBXVariantGroup;
			children = (
				607FACDA1AFB9204008FA782 /* Base */,
			);
			name = Main.storyboard;
			sourceTree = "<group>";
		};
		607FACDE1AFB9204008FA782 /* LaunchScreen.xib */ = {
			isa = PBXVariantGroup;
			children = (
				607FACDF1AFB9204008FA782 /* Base */,
			);
			name = LaunchScreen.xib;
			sourceTree = "<group>";
		};
/* End PBXVariantGroup section */

/* Begin XCBuildConfiguration section */
		607FACED1AFB9204008FA782 /* Debug */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ALWAYS_SEARCH_USER_PATHS = NO;
				CLANG_CXX_LANGUAGE_STANDARD = "gnu++0x";
				CLANG_CXX_LIBRARY = "libc++";
				CLANG_ENABLE_MODULES = YES;
				CLANG_ENABLE_OBJC_ARC = YES;
				CLANG_WARN_BLOCK_CAPTURE_AUTORELEASING = YES;
				CLANG_WARN_BOOL_CONVERSION = YES;
				CLANG_WARN_COMMA = YES;
				CLANG_WARN_CONSTANT_CONVERSION = YES;
				CLANG_WARN_DEPRECATED_OBJC_IMPLEMENTATIONS = YES;
				CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
				CLANG_WARN_EMPTY_BODY = YES;
				CLANG_WARN_ENUM_CONVERSION = YES;
				CLANG_WARN_INFINITE_RECURSION = YES;
				CLANG_WARN_INT_CONVERSION = YES;
				CLANG_WARN_NON_LITERAL_NULL_CONVERSION = YES;
				CLANG_WARN_OBJC_IMPLICIT_RETAIN_SELF = YES;
				CLANG_WARN_OBJC_LITERAL_CONVERSION = YES;
				CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
				CLANG_WARN_RANGE_LOOP_ANALYSIS = YES;
				CLANG_WARN_STRICT_PROTOTYPES = YES;
				CLANG_WARN_SUSPICIOUS_MOVE = YES;
				CLANG_WARN_UNREACHABLE_CODE = YES;
				CLANG_WARN__DUPLICATE_METHOD_MATCH = YES;
				"CODE_SIGN_IDENTITY[sdk=iphoneos*]" = "iPhone Developer";
				COPY_PHASE_STRIP = NO;
				DEBUG_INFORMATION_FORMAT = "dwarf-with-dsym";
				ENABLE_STRICT_OBJC_MSGSEND = YES;
				ENABLE_TESTABILITY = YES;
				GCC_C_LANGUAGE_STANDARD = gnu99;
				GCC_DYNAMIC_NO_PIC = NO;
				GCC_NO_COMMON_BLOCKS = YES;
				GCC_OPTIMIZATION_LEVEL = 0;
				GCC_PREPROCESSOR_DEFINITIONS = (
					"DEBUG=1",
					"$(inherited)",
				);
				GCC_SYMBOLS_PRIVATE_EXTERN = NO;
				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
				GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
				GCC_WARN_UNDECLARED_SELECTOR = YES;
				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
				GCC_WARN_UNUSED_FUNCTION = YES;
				GCC_WARN_UNUSED_VARIABLE = YES;
				IPHONEOS_DEPLOYMENT_TARGET = 9.0;
				MTL_ENABLE_DEBUG_INFO = YES;
				ONLY_ACTIVE_ARCH = YES;
				SDKROOT = iphoneos;
				SWIFT_OPTIMIZATION_LEVEL = "-Onone";
				SWIFT_VERSION = 5.0;
			};
			name = Debug;
		};
		607FACEE1AFB9204008FA782 /* Release */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ALWAYS_SEARCH_USER_PATHS = NO;
				CLANG_CXX_LANGUAGE_STANDARD = "gnu++0x";
				CLANG_CXX_LIBRARY = "libc++";
				CLANG_ENABLE_MODULES = YES;
				CLANG_ENABLE_OBJC_ARC = YES;
				CLANG_WARN_BLOCK_CAPTURE_AUTORELEASING = YES;
				CLANG_WARN_BOOL_CONVERSION = YES;
				CLANG_WARN_COMMA = YES;
				CLANG_WARN_CONSTANT_CONVERSION = YES;
				CLANG_WARN_DEPRECATED_OBJC_IMPLEMENTATIONS = YES;
				CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
				CLANG_WARN_EMPTY_BODY = YES;
				CLANG_WARN_ENUM_CONVERSION = YES;
				CLANG_WARN_INFINITE_RECURSION = YES;
				CLANG_WARN_INT_CONVERSION = YES;
				CLANG_WARN_NON_LITERAL_NULL_CONVERSION = YES;
				CLANG_WARN_OBJC_IMPLICIT_RETAIN_SELF = YES;
				CLANG_WARN_OBJC_LITERAL_CONVERSION = YES;
				CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
				CLANG_WARN_RANGE_LOOP_ANALYSIS = YES;
				CLANG_WARN_STRICT_PROTOTYPES = YES;
				CLANG_WARN_SUSPICIOUS_MOVE = YES;
				CLANG_WARN_UNREACHABLE_CODE = YES;
				CLANG_WARN__DUPLICATE_METHOD_MATCH = YES;
				"CODE_SIGN_IDENTITY[sdk=iphoneos*]" = "iPhone Developer";
				COPY_PHASE_STRIP = NO;
				DEBUG_INFORMATION_FORMAT = "dwarf-with-dsym";
				ENABLE_NS_ASSERTIONS = NO;
				ENABLE_STRICT_OBJC_MSGSEND = YES;
				GCC_C_LANGUAGE_STANDARD = gnu99;
				GCC_NO_COMMON_BLOCKS = YES;
				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
				GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
				GCC_WARN_UNDECLARED_SELECTOR = YES;
				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
				GCC_WARN_UNUSED_FUNCTION = YES;
				GCC_WARN_UNUSED_VARIABLE = YES;
				IPHONEOS_DEPLOYMENT_TARGET = 9.0;
				MTL_ENABLE_DEBUG_INFO = NO;
				SDKROOT = iphoneos;
				SWIFT_OPTIMIZATION_LEVEL = "-Owholemodule";
				SWIFT_VERSION = 5.0;
				VALIDATE_PRODUCT = YES;
			};
			name = Release;
		};
		607FACF01AFB9204008FA782 /* Debug */ = {
			isa = XCBuildConfiguration;
			baseConfigurationReference = 23024746510C90D82DBB9804 /* Pods-FrameLayoutKit_Example.debug.xcconfig */;
			buildSettings = {
				ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon;
				CODE_SIGN_ENTITLEMENTS = FrameLayoutKit/FrameLayoutKit_Example.entitlements;
				CODE_SIGN_IDENTITY = "iPhone Developer";
				DEVELOPMENT_TEAM = 385YL4KG69;
				INFOPLIST_FILE = FrameLayoutKit/Info.plist;
				IPHONEOS_DEPLOYMENT_TARGET = 9.0;
				LD_RUNPATH_SEARCH_PATHS = "$(inherited) @executable_path/Frameworks";
				MODULE_NAME = ExampleApp;
				PRODUCT_BUNDLE_IDENTIFIER = com.kennic.FrameLayoutExample;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SUPPORTS_MACCATALYST = YES;
				SUPPORTS_MAC_DESIGNED_FOR_IPHONE_IPAD = NO;
				SWIFT_SWIFT3_OBJC_INFERENCE = Default;
				SWIFT_VERSION = 5.0;
				TARGETED_DEVICE_FAMILY = "1,2,6";
			};
			name = Debug;
		};
		607FACF11AFB9204008FA782 /* Release */ = {
			isa = XCBuildConfiguration;
			baseConfigurationReference = AB5553AC3A0BA7787C1FD21B /* Pods-FrameLayoutKit_Example.release.xcconfig */;
			buildSettings = {
				ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon;
				CODE_SIGN_ENTITLEMENTS = FrameLayoutKit/FrameLayoutKit_Example.entitlements;
				CODE_SIGN_IDENTITY = "iPhone Developer";
				DEVELOPMENT_TEAM = 385YL4KG69;
				INFOPLIST_FILE = FrameLayoutKit/Info.plist;
				IPHONEOS_DEPLOYMENT_TARGET = 9.0;
				LD_RUNPATH_SEARCH_PATHS = "$(inherited) @executable_path/Frameworks";
				MODULE_NAME = ExampleApp;
				PRODUCT_BUNDLE_IDENTIFIER = com.kennic.FrameLayoutExample;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SUPPORTS_MACCATALYST = YES;
				SUPPORTS_MAC_DESIGNED_FOR_IPHONE_IPAD = NO;
				SWIFT_SWIFT3_OBJC_INFERENCE = Default;
				SWIFT_VERSION = 5.0;
				TARGETED_DEVICE_FAMILY = "1,2,6";
			};
			name = Release;
		};
/* End XCBuildConfiguration section */

/* Begin XCConfigurationList section */
		607FACCB1AFB9204008FA782 /* Build configuration list for PBXProject "FrameLayoutKit" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				607FACED1AFB9204008FA782 /* Debug */,
				607FACEE1AFB9204008FA782 /* Release */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
		607FACEF1AFB9204008FA782 /* Build configuration list for PBXNativeTarget "FrameLayoutKit_Example" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				607FACF01AFB9204008FA782 /* Debug */,
				607FACF11AFB9204008FA782 /* Release */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
/* End XCConfigurationList section */
	};
	rootObject = 607FACC81AFB9204008FA782 /* Project object */;
}



================================================
FILE: Example/FrameLayoutKit.xcodeproj/project.xcworkspace/contents.xcworkspacedata
================================================
<?xml version="1.0" encoding="UTF-8"?>
<Workspace
   version = "1.0">
   <FileRef
      location = "self:FrameLayoutKit.xcodeproj">
   </FileRef>
</Workspace>



================================================
FILE: Example/FrameLayoutKit.xcodeproj/project.xcworkspace/xcshareddata/IDEWorkspaceChecks.plist
================================================
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>IDEDidComputeMac32BitWarning</key>
	<true/>
</dict>
</plist>



================================================
FILE: Example/FrameLayoutKit.xcodeproj/xcshareddata/xcschemes/FrameLayoutKit-Example.xcscheme
================================================
<?xml version="1.0" encoding="UTF-8"?>
<Scheme
   LastUpgradeVersion = "1000"
   version = "1.3">
   <BuildAction
      parallelizeBuildables = "YES"
      buildImplicitDependencies = "YES">
      <BuildActionEntries>
         <BuildActionEntry
            buildForTesting = "YES"
            buildForRunning = "YES"
            buildForProfiling = "YES"
            buildForArchiving = "YES"
            buildForAnalyzing = "YES">
            <BuildableReference
               BuildableIdentifier = "primary"
               BlueprintIdentifier = "607FACCF1AFB9204008FA782"
               BuildableName = "FrameLayoutKit_Example.app"
               BlueprintName = "FrameLayoutKit_Example"
               ReferencedContainer = "container:FrameLayoutKit.xcodeproj">
            </BuildableReference>
         </BuildActionEntry>
         <BuildActionEntry
            buildForTesting = "YES"
            buildForRunning = "YES"
            buildForProfiling = "NO"
            buildForArchiving = "NO"
            buildForAnalyzing = "YES">
            <BuildableReference
               BuildableIdentifier = "primary"
               BlueprintIdentifier = "607FACE41AFB9204008FA782"
               BuildableName = "FrameLayoutKit_Tests.xctest"
               BlueprintName = "FrameLayoutKit_Tests"
               ReferencedContainer = "container:FrameLayoutKit.xcodeproj">
            </BuildableReference>
         </BuildActionEntry>
      </BuildActionEntries>
   </BuildAction>
   <TestAction
      buildConfiguration = "Debug"
      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.LLDB"
      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.LLDB"
      shouldUseLaunchSchemeArgsEnv = "YES">
      <MacroExpansion>
         <BuildableReference
            BuildableIdentifier = "primary"
            BlueprintIdentifier = "607FACCF1AFB9204008FA782"
            BuildableName = "FrameLayoutKit_Example.app"
            BlueprintName = "FrameLayoutKit_Example"
            ReferencedContainer = "container:FrameLayoutKit.xcodeproj">
         </BuildableReference>
      </MacroExpansion>
      <Testables>
         <TestableReference
            skipped = "NO">
            <BuildableReference
               BuildableIdentifier = "primary"
               BlueprintIdentifier = "607FACE41AFB9204008FA782"
               BuildableName = "FrameLayoutKit_Tests.xctest"
               BlueprintName = "FrameLayoutKit_Tests"
               ReferencedContainer = "container:FrameLayoutKit.xcodeproj">
            </BuildableReference>
         </TestableReference>
      </Testables>
   </TestAction>
   <LaunchAction
      buildConfiguration = "Debug"
      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.LLDB"
      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.LLDB"
      launchStyle = "0"
      useCustomWorkingDirectory = "NO"
      ignoresPersistentStateOnLaunch = "NO"
      debugDocumentVersioning = "YES"
      debugServiceExtension = "internal"
      allowLocationSimulation = "YES">
      <BuildableProductRunnable
         runnableDebuggingMode = "0">
         <BuildableReference
            BuildableIdentifier = "primary"
            BlueprintIdentifier = "607FACCF1AFB9204008FA782"
            BuildableName = "FrameLayoutKit_Example.app"
            BlueprintName = "FrameLayoutKit_Example"
            ReferencedContainer = "container:FrameLayoutKit.xcodeproj">
         </BuildableReference>
      </BuildableProductRunnable>
   </LaunchAction>
   <ProfileAction
      buildConfiguration = "Release"
      shouldUseLaunchSchemeArgsEnv = "YES"
      savedToolIdentifier = ""
      useCustomWorkingDirectory = "NO"
      debugDocumentVersioning = "YES">
      <BuildableProductRunnable
         runnableDebuggingMode = "0">
         <BuildableReference
            BuildableIdentifier = "primary"
            BlueprintIdentifier = "607FACCF1AFB9204008FA782"
            BuildableName = "FrameLayoutKit_Example.app"
            BlueprintName = "FrameLayoutKit_Example"
            ReferencedContainer = "container:FrameLayoutKit.xcodeproj">
         </BuildableReference>
      </BuildableProductRunnable>
   </ProfileAction>
   <AnalyzeAction
      buildConfiguration = "Debug">
   </AnalyzeAction>
   <ArchiveAction
      buildConfiguration = "Release"
      revealArchiveInOrganizer = "YES">
   </ArchiveAction>
</Scheme>



================================================
FILE: Example/FrameLayoutKit.xcworkspace/contents.xcworkspacedata
================================================
<?xml version="1.0" encoding="UTF-8"?>
<Workspace
   version = "1.0">
   <FileRef
      location = "group:FrameLayoutKit.xcodeproj">
   </FileRef>
   <FileRef
      location = "group:Pods/Pods.xcodeproj">
   </FileRef>
</Workspace>



================================================
FILE: Example/FrameLayoutKit.xcworkspace/xcshareddata/IDEWorkspaceChecks.plist
================================================
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>IDEDidComputeMac32BitWarning</key>
	<true/>
</dict>
</plist>



================================================
FILE: Example/FrameLayoutKit.xcworkspace/xcshareddata/WorkspaceSettings.xcsettings
================================================
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>PreviewsEnabled</key>
	<false/>
</dict>
</plist>



================================================
FILE: Example/FrameLayoutKit.xcworkspace/xcuserdata/namkennic.xcuserdatad/WorkspaceSettings.xcsettings
================================================
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>BuildLocationStyle</key>
	<string>UseAppPreferences</string>
	<key>CustomBuildLocationType</key>
	<string>RelativeToDerivedData</string>
	<key>DerivedDataLocationStyle</key>
	<string>Default</string>
	<key>IssueFilterStyle</key>
	<string>ShowActiveSchemeOnly</string>
	<key>LiveSourceIssuesEnabled</key>
	<true/>
	<key>ShowSharedSchemesAutomaticallyEnabled</key>
	<true/>
</dict>
</plist>



================================================
FILE: Example/FrameLayoutKit.xcworkspace/xcuserdata/namkennic.xcuserdatad/xcdebugger/Breakpoints_v2.xcbkptlist
================================================
<?xml version="1.0" encoding="UTF-8"?>
<Bucket
   uuid = "F3468A4C-D15A-4E2C-8A4F-6AAE8B441AB8"
   type = "0"
   version = "2.0">
</Bucket>



================================================
FILE: FrameLayoutKit/Classes/DoubleFrameLayout.swift
================================================
//
//  DoubleFrameLayout.swift
//  FrameLayoutKit
//
//  Created by Nam Kennic on 7/17/18.
//

import UIKit

public enum NKLayoutAxis {
    case horizontal // left - right
    case vertical // top - bottom
}

public enum NKLayoutDistribution: Equatable {
	case top
    case bottom
    case equal
	case split(ratio: [CGFloat])
    case center
	
	public static let left: NKLayoutDistribution = .top
	public static let right: NKLayoutDistribution = .bottom
	
	public init(split ratio: CGFloat...) {
		self = .split(ratio: ratio)
	}
}

/*
@propertyWrapper
public struct Clamping<Value: Comparable> {
	var value: Value
	let range: ClosedRange<Value>
	
	public init(wrappedValue value: Value, _ range: ClosedRange<Value>) {
		precondition(range.contains(value))
		self.value = value
		self.range = range
	}
	
	public var wrappedValue: Value {
		get { value }
		set { value = min(max(range.lowerBound, newValue), range.upperBound) }
	}
}

@propertyWrapper
public struct UnitPercentage<Value: FloatingPoint> {
	@Clamping(0...1)
	public var wrappedValue: Value = .zero
	
	public init(wrappedValue value: Value) {
		self.wrappedValue = value
	}
}
*/

open class DoubleFrameLayout: FrameLayout {
	public var distribution: NKLayoutDistribution = .top
	public var axis: NKLayoutAxis = .vertical
	
	public var spacing: CGFloat = 0 {
		didSet {
			if spacing != oldValue {
				setNeedsLayout()
			}
		}
	}
	
	override open var ignoreHiddenView: Bool {
		didSet {
			frameLayout1.ignoreHiddenView = ignoreHiddenView
			frameLayout2.ignoreHiddenView = ignoreHiddenView
		}
	}
	
	override open var shouldCacheSize: Bool {
		didSet {
			frameLayout1.shouldCacheSize = shouldCacheSize
			frameLayout2.shouldCacheSize = shouldCacheSize
		}
	}
	
	override open var debug: Bool {
		didSet {
			super.debug = debug
			frameLayout1.debug = debug
			frameLayout2.debug = debug
		}
	}
	
	override open var debugColor: UIColor?{
		didSet {
			super.debugColor = debugColor
			frameLayout1.debugColor = debugColor
			frameLayout2.debugColor = debugColor
		}
	}
	
	override open var allowContentVerticalGrowing: Bool {
		didSet {
			frameLayout1.allowContentVerticalGrowing = allowContentVerticalGrowing
			frameLayout2.allowContentVerticalGrowing = allowContentVerticalGrowing
		}
	}
	
	override open var allowContentVerticalShrinking: Bool {
		didSet {
			frameLayout1.allowContentVerticalShrinking = allowContentVerticalShrinking
			frameLayout2.allowContentVerticalShrinking = allowContentVerticalShrinking
		}
	}
	
	override open var allowContentHorizontalGrowing: Bool {
		didSet {
			frameLayout1.allowContentHorizontalGrowing = allowContentHorizontalGrowing
			frameLayout2.allowContentHorizontalGrowing = allowContentHorizontalGrowing
		}
	}
	
	override open var allowContentHorizontalShrinking: Bool {
		didSet {
			frameLayout1.allowContentHorizontalShrinking = allowContentHorizontalShrinking
			frameLayout2.allowContentHorizontalShrinking = allowContentHorizontalShrinking
		}
	}
	
	override open var frame: CGRect {
		didSet { setNeedsLayout() }
	}
	
	override open var bounds: CGRect {
		didSet { setNeedsLayout() }
	}
	
	override open var description: String {
		return "[\(super.description)]\n[frameLayout1: \(String(describing: frameLayout1))]\n-[frameLayout2: \(String(describing: frameLayout2))]"
	}
	
	// Skeleton
	
	/// set color for skeleton mode
	override public var skeletonColor: UIColor {
		get { frameLayout1.skeletonColor }
		set {
			super.skeletonColor = newValue
			frameLayout1.skeletonColor = newValue
			frameLayout2.skeletonColor = newValue
		}
	}
	override public var skeletonMinSize: CGSize {
		get { frameLayout1.skeletonMinSize }
		set {
			frameLayout1.skeletonMinSize = newValue
			frameLayout2.skeletonMinSize = newValue
		}
	}
	override public var skeletonMaxSize: CGSize {
		get { frameLayout1.skeletonMaxSize }
		set {
			frameLayout1.skeletonMaxSize = newValue
			frameLayout2.skeletonMaxSize = newValue
		}
	}
	override public var isSkeletonMode: Bool {
		didSet {
			frameLayout1.isSkeletonMode = isSkeletonMode
			frameLayout2.isSkeletonMode = isSkeletonMode
		}
	}
	
	// MARK: -
	
	public var frameLayout1: FrameLayout = FrameLayout() {
		didSet {
			guard frameLayout1 != oldValue else { return }
			
			if oldValue.superview == self {
				oldValue.parent = nil
				oldValue.removeFromSuperview()
			}
			
			if frameLayout1 != self {
				frameLayout1.parent = self
				addSubview(frameLayout1)
			}
		}
	}
	
	public var frameLayout2: FrameLayout = FrameLayout() {
		didSet {
			guard frameLayout2 != oldValue else { return }
			
			if oldValue.superview == self {
				oldValue.parent = nil
				oldValue.removeFromSuperview()
			}
			
			if frameLayout2 != self {
				frameLayout2.parent = self
				addSubview(frameLayout2)
			}
		}
	}
	
	public var topFrameLayout: FrameLayout {
		get { frameLayout1 }
		set { frameLayout1 = newValue }
	}
	
	public var leftFrameLayout: FrameLayout {
		get { frameLayout1 }
		set { frameLayout1 = newValue }
	}
	
	public var bottomFrameLayout: FrameLayout {
		get { frameLayout2 }
		set { frameLayout2 = newValue }
	}
	
	public var rightFrameLayout: FrameLayout {
		get { frameLayout2 }
		set { frameLayout2 = newValue }
	}
	
	public var isOverlapped: Bool = false {
		didSet { setNeedsLayout() }
	}
	
	public override var isUserInteractionEnabled: Bool {
		didSet {
			frameLayout1.isUserInteractionEnabled = isUserInteractionEnabled
			frameLayout2.isUserInteractionEnabled = isUserInteractionEnabled
		}
	}
	
	// MARK: -
	
	@discardableResult
	public convenience init(_ block: (DoubleFrameLayout) throws -> Void) rethrows {
		self.init()
		try block(self)
	}
	
	convenience public init(axis: NKLayoutAxis, distribution: NKLayoutDistribution = .top, views: [UIView]? = nil) {
		self.init()
		
		self.axis = axis
		self.distribution = distribution
		
		defer {
			if let views {
				let count = views.count
				
				if count > 0 {
					var targetView = views[0]
					
					if targetView is FrameLayout && targetView.superview == nil {
						frameLayout1 = targetView as! FrameLayout
					}
					else {
						frameLayout1.targetView = targetView
					}
					
					if count > 1 {
						targetView = views[1]
						
						if targetView is FrameLayout && targetView.superview == nil {
							frameLayout2 = targetView as! FrameLayout
						}
						else {
							frameLayout2.targetView = targetView
						}
						
						#if DEBUG
						if count > 2 {
							print("[\(self)] This DoubleFrameLayout should has only 2 target views, currently set \(count) views. Switch to StackFrameLayout to handle multi views.")
						}
						#endif
					}
				}
			}
		}
	}
	
	public required init() {
		super.init()
		
		addSubview(frameLayout1)
		addSubview(frameLayout2)
	}
	
	public required init?(coder aDecoder: NSCoder) {
		super.init(coder: aDecoder)
	}
	
	// MARK: -
	
	@discardableResult
	open func setLeft(_ view: UIView?) -> FrameLayout {
		if let frameLayout = view as? FrameLayout, frameLayout.superview == nil {
			self.frameLayout1 = frameLayout
			return frameLayout
		}
		
		frameLayout1.targetView = view
		return frameLayout1
	}
	
	@discardableResult
	open func setRight(_ view: UIView?) -> FrameLayout {
		if let frameLayout = view as? FrameLayout, frameLayout.superview == nil {
			self.frameLayout2 = frameLayout
			return frameLayout
		}
		
		frameLayout2.targetView = view
		return frameLayout2
	}
	
	@discardableResult
	open func setTop(_ view: UIView?) -> FrameLayout {
		return setLeft(view)
	}
	
	@discardableResult
	open func setBottom(_ view: UIView?) -> FrameLayout {
		return setRight(view)
	}
	
	// MARK: -
	
	override open func setNeedsLayout() {
		super.setNeedsLayout()
		
		frameLayout1.setNeedsLayout()
		frameLayout2.setNeedsLayout()
	}
	
	open override func sizeThatFits(_ size: CGSize, ignoreHiddenView: Bool) -> CGSize {
		if !isEnabled { return .zero }
		
		willSizeThatFitsBlock?(self, size)
		
		var result: CGSize = size
		
		let verticalEdgeValues = edgeInsets.left + edgeInsets.right
		let horizontalEdgeValues = edgeInsets.top + edgeInsets.bottom
		
		if minSize == maxSize && minSize.width > 0 && minSize.height > 0 {
			result = minSize
		}
		else if heightRatio > 0 && !isIntrinsicSizeEnabled {
			result.height = result.width * heightRatio
		}
		else {
			let contentSize = CGSize(width: max(size.width - verticalEdgeValues, 0), height: max(size.height - horizontalEdgeValues, 0))
			
			var frame1ContentSize: CGSize = .zero
			var frame2ContentSize: CGSize = .zero
			
			if isOverlapped {
				frame1ContentSize = frameLayout1.sizeThatFits(contentSize)
				frame2ContentSize = frameLayout2.sizeThatFits(contentSize)
				
				result.width = isIntrinsicSizeEnabled ? max(frame1ContentSize.width, frame2ContentSize.width) : size.width
				
				if heightRatio > 0 {
					result.height = result.width * heightRatio
				}
				else {
					result.height = max(frame1ContentSize.height, frame2ContentSize.height)
				}
				
				return result
			}
			
			var space: CGFloat = 0
			
			if axis == .horizontal {
				switch distribution {
				case .left, .top:
					frame1ContentSize = frameLayout1.sizeThatFits(contentSize)
					space = frame1ContentSize.width > 0 ? spacing : 0
					
					frame2ContentSize = frameLayout2.sizeThatFits(CGSize(width: contentSize.width - frame1ContentSize.width - space, height: contentSize.height), intrinsic: isIntrinsicSizeEnabled || frameLayout2.heightRatio == 0)
					break
					
				case .right, .bottom:
					frame2ContentSize = frameLayout2.sizeThatFits(contentSize)
					space = frame2ContentSize.width > 0 ? spacing : 0
					
					frame1ContentSize = frameLayout1.sizeThatFits(CGSize(width: contentSize.width - frame2ContentSize.width - space, height: contentSize.height), intrinsic: isIntrinsicSizeEnabled || frameLayout1.heightRatio == 0)
					break
					
				case .equal:
					var ratioValue: CGFloat = 0.5
					var spaceValue: CGFloat = spacing
					
					if frameLayout1.isEmpty {
						ratioValue = 0
						spaceValue = 0
					}
					
					if frameLayout2.isEmpty {
						ratioValue = 1
						spaceValue = 0
					}
					
					frame1ContentSize = frameLayout1.sizeThatFits(CGSize(width: (contentSize.width - spaceValue) * ratioValue, height: contentSize.height), intrinsic: isIntrinsicSizeEnabled || frameLayout1.heightRatio == 0)
					space = frame1ContentSize.width > 0 ? spaceValue : 0
					
					frame2ContentSize = frameLayout2.sizeThatFits(CGSize(width: contentSize.width - frame1ContentSize.width - space, height: contentSize.height), intrinsic: isIntrinsicSizeEnabled || frameLayout2.heightRatio == 0)
					
					if frame1ContentSize.width > frame2ContentSize.width {
						frame2ContentSize.width = frame1ContentSize.width
						
						if frameLayout2.heightRatio > 0 {
							frame2ContentSize.height = frame2ContentSize.width * heightRatio
						}
					}
					else if frame2ContentSize.width > frame1ContentSize.width {
						frame1ContentSize.width = frame2ContentSize.width
						
						if frameLayout1.heightRatio > 0 {
							frame1ContentSize.height = frame1ContentSize.width * heightRatio
						}
					}
					
					break
					
				case .split(let ratio):
					var ratioValue: CGFloat = ratio.first ?? 0.5
					var spaceValue: CGFloat = spacing
					
					if frameLayout1.isEmpty {
						ratioValue = 0
						spaceValue = 0
					}
					
					if frameLayout2.isEmpty {
						ratioValue = 1
						spaceValue = 0
					}
					
					frame1ContentSize = frameLayout1.sizeThatFits(CGSize(width: (contentSize.width - spaceValue) * ratioValue, height: contentSize.height), intrinsic: isIntrinsicSizeEnabled || frameLayout1.heightRatio == 0)
					space = frame1ContentSize.width > 0 ? spaceValue : 0
					
					frame2ContentSize = frameLayout2.sizeThatFits(CGSize(width: contentSize.width - frame1ContentSize.width - space, height: contentSize.height), intrinsic: isIntrinsicSizeEnabled || frameLayout2.heightRatio == 0)
					
					if frame1ContentSize.width > frame2ContentSize.width {
						frame2ContentSize.width = frame1ContentSize.width
						
						if frameLayout2.heightRatio > 0 {
							frame2ContentSize.height = frame2ContentSize.width * heightRatio
						}
					}
					else if frame2ContentSize.width > frame1ContentSize.width {
						frame1ContentSize.width = frame2ContentSize.width
						
						if frameLayout1.heightRatio > 0 {
							frame1ContentSize.height = frame1ContentSize.width * heightRatio
						}
					}
					break
					
				case .center:
					frame1ContentSize = frameLayout1.sizeThatFits(contentSize)
					space = frame1ContentSize.width > 0 ? spacing : 0
					
					frame2ContentSize = frameLayout2.sizeThatFits(CGSize(width: contentSize.width - frame1ContentSize.width - space, height: contentSize.height))
					break
				}
				
				if isIntrinsicSizeEnabled {
					space = frame1ContentSize.width > 0 && frame2ContentSize.width > 0 ? spacing : 0
					result.width = frame1ContentSize.width + frame2ContentSize.width + space
				}
				else {
					result.width = size.width
				}
				
				if heightRatio > 0 {
					result.height = result.width * heightRatio
				}
				else {
					result.height = max(frame1ContentSize.height, frame2ContentSize.height)
				}
			}
			else {
				switch distribution {
				case .top, .left:
					frame1ContentSize = frameLayout1.sizeThatFits(contentSize)
					space = frame1ContentSize.height > 0 ? spacing : 0
					
					frame2ContentSize = frameLayout2.sizeThatFits(CGSize(width: contentSize.width, height: contentSize.height - frame1ContentSize.height - space))
					
					if frame1ContentSize.width > frame2ContentSize.width {
						if frameLayout2.heightRatio > 0 {
							frame2ContentSize.height = frame1ContentSize.width * heightRatio
						}
					}
					else if frame2ContentSize.width > frame1ContentSize.width {
						if frameLayout1.heightRatio > 0 {
							frame1ContentSize.height = frame2ContentSize.width * heightRatio
						}
					}
					
					break
					
				case .bottom, .right:
					frame2ContentSize = frameLayout2.sizeThatFits(contentSize)
					space = frame2ContentSize.height > 0 ? spacing : 0
					
					frame1ContentSize = frameLayout1.sizeThatFits(CGSize(width: contentSize.width, height: contentSize.height - frame2ContentSize.height - space))
					
					if frame1ContentSize.width > frame2ContentSize.width {
						if frameLayout2.heightRatio > 0 {
							frame2ContentSize.height = frame1ContentSize.width * heightRatio
						}
					}
					else if frame2ContentSize.width > frame1ContentSize.width {
						if frameLayout1.heightRatio > 0 {
							frame1ContentSize.height = frame2ContentSize.width * heightRatio
						}
					}
					
					break
					
				case .equal:
					var ratioValue: CGFloat = 0.5
					var spaceValue: CGFloat = spacing
					
					if frameLayout1.isEmpty {
						ratioValue = 0
						spaceValue = 0
					}
					
					if frameLayout2.isEmpty  {
						ratioValue = 1
						spaceValue = 0
					}
					
					frame1ContentSize = frameLayout1.sizeThatFits(CGSize(width: contentSize.width, height: (contentSize.height - spaceValue) * ratioValue))
					space = frame1ContentSize.height > 0 ? spaceValue : 0
					
					frame2ContentSize = frameLayout2.sizeThatFits(CGSize(width: contentSize.width, height: contentSize.height - frame1ContentSize.height - space))
					
					if frameLayout2.heightRatio > 0 {
						if frame1ContentSize.width > frame2ContentSize.width {
							frame2ContentSize.height = frame1ContentSize.width * heightRatio
						}
					}
					
					if frameLayout1.heightRatio > 0 {
						if frame2ContentSize.width > frame1ContentSize.width {
							frame1ContentSize.height = frame2ContentSize.width * heightRatio
						}
					}
					
					if frame1ContentSize.height > frame2ContentSize.height {
						frame2ContentSize.height = frame1ContentSize.height
					}
					else if frame2ContentSize.height > frame1ContentSize.height {
						frame1ContentSize.height = frame2ContentSize.height
					}
					
					break
					
				case .split(let ratio):
					var ratioValue: CGFloat = ratio.first ?? 0.5
					var spaceValue: CGFloat = spacing
					
					if frameLayout1.isEmpty {
						ratioValue = 0
						spaceValue = 0
					}
					
					if frameLayout2.isEmpty  {
						ratioValue = 1
						spaceValue = 0
					}
					
					frame1ContentSize = frameLayout1.sizeThatFits(CGSize(width: contentSize.width, height: (contentSize.height - spaceValue) * ratioValue))
					space = frame1ContentSize.height > 0 ? spaceValue : 0
					
					frame2ContentSize = frameLayout2.sizeThatFits(CGSize(width: contentSize.width, height: contentSize.height - frame1ContentSize.height - space))
					
					if frameLayout2.heightRatio > 0 {
						if frame1ContentSize.width > frame2ContentSize.width {
							frame2ContentSize.height = frame1ContentSize.width * heightRatio
						}
					}
					
					if frameLayout1.heightRatio > 0 {
						if frame2ContentSize.width > frame1ContentSize.width {
							frame1ContentSize.height = frame2ContentSize.width * heightRatio
						}
					}
					
					if frame1ContentSize.height > frame2ContentSize.height {
						frame2ContentSize.height = frame1ContentSize.height
					}
					else if frame2ContentSize.height > frame1ContentSize.height {
						frame1ContentSize.height = frame2ContentSize.height
					}
						break
					
				case .center:
					frame1ContentSize = frameLayout1.sizeThatFits(contentSize)
					frame2ContentSize = frameLayout2.sizeThatFits(contentSize)
					break
				}
				
				result.width = isIntrinsicSizeEnabled ? max(frame1ContentSize.width, frame2ContentSize.width) : size.width
				if heightRatio > 0 {
					result.height = result.width * heightRatio
				}
				else {
					space = frame1ContentSize.height > 0 && frame2ContentSize.height > 0 ? spacing : 0
					result.height = frame1ContentSize.height + frame2ContentSize.height + space
				}
			}
			
			result.limitedTo(minSize: minSize, maxSize: maxSize)
		}
		
		if result.width > 0 { result.width += verticalEdgeValues }
		if result.height > 0 { result.height += horizontalEdgeValues }
		
		result.width = min(result.width, size.width)
		result.height = min(result.height, size.height)
		
		return result
	}
	
	override open func layoutSubviews() {
		super.layoutSubviews()
		if !isEnabled { return }
		
		defer {
			didLayoutSubviewsBlock?(self)
		}
		
		#if swift(>=4.2)
		let containerFrame: CGRect = bounds.inset(by: edgeInsets)
		#else
		let containerFrame: CGRect = UIEdgeInsetsInsetRect(bounds, edgeInsets)
		#endif
		
		guard !containerFrame.isEmpty else { return }
		
		var frame1ContentSize: CGSize = .zero
		var frame2ContentSize: CGSize = .zero
		var targetFrame1: CGRect = containerFrame
		var targetFrame2: CGRect = containerFrame
		var space: CGFloat = 0
		
		if axis == .horizontal {
			switch distribution {
			case .top, .left:
				frame1ContentSize = frameLayout1.sizeThatFits(containerFrame.size)
				targetFrame1.size.width = frame1ContentSize.width
				
				if isOverlapped {
					if frameLayout2.isIntrinsicSizeEnabled && !frameLayout2.isFlexible {
						frame2ContentSize = frameLayout2.sizeThatFits(containerFrame.size)
						targetFrame2.size.width = min(frame2ContentSize.width, containerFrame.width)
					}
					else {
						targetFrame2.size.width = containerFrame.width
					}
				}
				else {
					space = frame1ContentSize.width > 0 ? spacing : 0
					
					frame2ContentSize = CGSize(width: containerFrame.width - frame1ContentSize.width - space, height: containerFrame.height)
					targetFrame2.origin.x = containerFrame.minX + frame1ContentSize.width + space
					targetFrame2.size.width = frame2ContentSize.width
				}
				break
				
			case .bottom, .right:
				frame2ContentSize = frameLayout2.sizeThatFits(containerFrame.size, intrinsic: true)
				targetFrame2.origin.x = containerFrame.minX + (containerFrame.width - frame2ContentSize.width)
				targetFrame2.size.width = frame2ContentSize.width
				
				if isOverlapped {
					if frameLayout1.isIntrinsicSizeEnabled && !frameLayout1.isFlexible {
						frame1ContentSize = frameLayout1.sizeThatFits(containerFrame.size)
						targetFrame1.size.width = min(frame1ContentSize.width, containerFrame.width)
						targetFrame1.origin.x = containerFrame.minX + (containerFrame.width - targetFrame1.width)
					}
					else {
						targetFrame1.size.width = containerFrame.width
					}
				}
				else {
					space = frame2ContentSize.width > 0 ? spacing : 0
					
					frame1ContentSize = CGSize(width: containerFrame.width - frame2ContentSize.width - space, height: containerFrame.height)
					targetFrame1.size.width = frame1ContentSize.width
				}
				break
				
			case .equal:
				if isOverlapped {
					targetFrame1 = containerFrame
					targetFrame2 = containerFrame
				}
				else {
					var ratioValue: CGFloat = 0.5
					var spaceValue = spacing
					
					if frameLayout1.isEmpty {
						ratioValue = 0
						spaceValue = 0
					}
					
					if frameLayout2.isEmpty {
						ratioValue = 1
						spaceValue = 0
					}
					
					frame1ContentSize = CGSize(width: (containerFrame.width - spaceValue) * ratioValue, height: containerFrame.height)
					targetFrame1.size.width = frame1ContentSize.width
					space = frame1ContentSize.width > 0 ? spaceValue : 0
					
					frame2ContentSize = CGSize(width: containerFrame.width - frame1ContentSize.width - space, height: containerFrame.height)
					targetFrame2.origin.x = containerFrame.minX + frame1ContentSize.width + space
					targetFrame2.size.width = frame2ContentSize.width
				}
				break
				
			case .split(let ratio):
				if isOverlapped {
					targetFrame1 = containerFrame
					targetFrame2 = containerFrame
				}
				else {
					var ratioValue = ratio.first ?? 0.5
					var spaceValue = spacing
					
					if frameLayout1.isEmpty {
						ratioValue = 0
						spaceValue = 0
					}
					
					if frameLayout2.isEmpty {
						ratioValue = 1
						spaceValue = 0
					}
					
					frame1ContentSize = CGSize(width: (containerFrame.width - spaceValue) * ratioValue, height: containerFrame.height)
					targetFrame1.size.width = frame1ContentSize.width
					space = frame1ContentSize.width > 0 ? spaceValue : 0
					
					frame2ContentSize = CGSize(width: containerFrame.width - frame1ContentSize.width - space, height: containerFrame.height)
					targetFrame2.origin.x = containerFrame.minX + frame1ContentSize.width + space
					targetFrame2.size.width = frame2ContentSize.width
				}
				break
				
			case .center:
				if isOverlapped {
					frame1ContentSize = frameLayout1.isFlexible ? containerFrame.size : frameLayout1.sizeThatFits(containerFrame.size)
					frame2ContentSize = frameLayout2.isFlexible ? containerFrame.size : frameLayout2.sizeThatFits(containerFrame.size)
					targetFrame1.size.width = min(frame1ContentSize.width, containerFrame.width)
					targetFrame2.size.width = min(frame2ContentSize.width, containerFrame.width)
					targetFrame1.origin.x = containerFrame.minX + (containerFrame.width - targetFrame1.width)/2
					targetFrame2.origin.x = containerFrame.minX + (containerFrame.width - targetFrame2.width)/2
				}
				else {
					frame1ContentSize = frameLayout1.sizeThatFits(containerFrame.size)
					space = frame1ContentSize.width > 0 ? spacing : 0
					
					frame2ContentSize = frameLayout2.sizeThatFits(CGSize(width: containerFrame.width - frame1ContentSize.width - space, height: containerFrame.height))
					
					let totalWidth = frame1ContentSize.width + frame2ContentSize.width + space
					targetFrame1.origin.x = containerFrame.minX + (containerFrame.width - totalWidth)/2
					targetFrame1.size.width = frame1ContentSize.width
					
					targetFrame2.origin.x = targetFrame1.minX + frame1ContentSize.width + space
					targetFrame2.size.width = frame2ContentSize.width
				}
				break
			}
		}
		else {
			switch distribution {
			case .top, .left:
				frame1ContentSize = frameLayout1.sizeThatFits(containerFrame.size, intrinsic: frameLayout1.heightRatio == 0)
				targetFrame1.size.height = frame1ContentSize.height
				
				if isOverlapped {
					if frameLayout2.isIntrinsicSizeEnabled && !frameLayout2.isFlexible {
						frame2ContentSize = frameLayout2.sizeThatFits(containerFrame.size, intrinsic: frameLayout2.heightRatio == 0)
						targetFrame2.size.height = min(frame2ContentSize.height, containerFrame.height)
					}
					else {
						targetFrame2.size.height = containerFrame.height
					}
				}
				else {
					space = frame1ContentSize.height > 0 ? spacing : 0
					
					frame2ContentSize = CGSize(width: containerFrame.width, height: containerFrame.height - frame1ContentSize.height - space)
					targetFrame2.origin.y = containerFrame.minY + frame1ContentSize.height + space
					targetFrame2.size.height = frame2ContentSize.height
				}
				break
				
			case .bottom, .right:
				frame2ContentSize = frameLayout2.sizeThatFits(containerFrame.size, intrinsic: frameLayout2.heightRatio == 0)
				targetFrame2.origin.y = containerFrame.minY + (containerFrame.height - frame2ContentSize.height)
				targetFrame2.size.height = frame2ContentSize.height
				
				if isOverlapped {
					if frameLayout1.isIntrinsicSizeEnabled && !frameLayout1.isFlexible {
						frame1ContentSize = frameLayout1.sizeThatFits(containerFrame.size, intrinsic: frameLayout1.heightRatio == 0)
						targetFrame1.size.height = min(frame1ContentSize.height, containerFrame.height)
						targetFrame1.origin.y = containerFrame.minY + (containerFrame.height - targetFrame1.height)
					}
					else {
						targetFrame1.size.height = containerFrame.height
					}
				}
				else {
					space = frame2ContentSize.height > 0 ? spacing : 0
					
					frame1ContentSize = CGSize(width: containerFrame.width, height: containerFrame.height - frame2ContentSize.height - space)
					targetFrame1.size.height = frame1ContentSize.height
				}
				break
				
			case .equal:
				if isOverlapped {
					targetFrame1 = containerFrame
					targetFrame2 = containerFrame
				}
				else {
					var ratioValue: CGFloat = 0.5
					var spaceValue = spacing
					
					if frameLayout1.isEmpty {
						ratioValue = 0
						spaceValue = 0
					}
					
					if frameLayout2.isEmpty {
						ratioValue = 1
						spaceValue = 0
					}
					
					frame1ContentSize = CGSize(width: containerFrame.width, height: (containerFrame.height - spaceValue) * ratioValue)
					targetFrame1.size.height = frame1ContentSize.height
					space = frame1ContentSize.height > 0 ? spaceValue : 0
					
					frame2ContentSize = CGSize(width: containerFrame.width, height: containerFrame.height - frame1ContentSize.height - space)
					targetFrame2.origin.y = containerFrame.minY + targetFrame1.height + space
					targetFrame2.size.height = frame2ContentSize.height
				}
				break
				
			case .split(let ratio):
					if isOverlapped {
						targetFrame1 = containerFrame
						targetFrame2 = containerFrame
					}
					else {
						var ratioValue = ratio.first ?? 0.5
						var spaceValue = spacing
						
						if frameLayout1.isEmpty {
							ratioValue = 0
							spaceValue = 0
						}
						
						if frameLayout2.isEmpty {
							ratioValue = 1
							spaceValue = 0
						}
						
						frame1ContentSize = CGSize(width: containerFrame.width, height: (containerFrame.height - spaceValue) * ratioValue)
						targetFrame1.size.height = frame1ContentSize.height
						space = frame1ContentSize.height > 0 ? spaceValue : 0
						
						frame2ContentSize = CGSize(width: containerFrame.width, height: containerFrame.height - frame1ContentSize.height - space)
						targetFrame2.origin.y = containerFrame.minY + targetFrame1.height + space
						targetFrame2.size.height = frame2ContentSize.height
					}
					break
				
			case .center:
				if isOverlapped {
					frame1ContentSize = frameLayout1.isFlexible ? containerFrame.size : frameLayout1.sizeThatFits(containerFrame.size)
					frame2ContentSize = frameLayout2.isFlexible ? containerFrame.size : frameLayout2.sizeThatFits(containerFrame.size)
					targetFrame1.size.height = min(frame1ContentSize.height, containerFrame.height)
					targetFrame2.size.height = min(frame2ContentSize.height, containerFrame.height)
					targetFrame1.origin.y = containerFrame.minY + (containerFrame.height - targetFrame1.height)/2
					targetFrame2.origin.y = containerFrame.minY + (containerFrame.height - targetFrame2.height)/2
				}
				else {
					frame1ContentSize = frameLayout1.sizeThatFits(containerFrame.size)
					space = frame1ContentSize.height > 0 ? spacing : 0
					
					frame2ContentSize = frameLayout2.sizeThatFits(CGSize(width: containerFrame.width, height: containerFrame.height - frame1ContentSize.height - space))
					
					let totalHeight: CGFloat = frame1ContentSize.height + frame2ContentSize.height + space
					targetFrame1.origin.y = containerFrame.minY + (containerFrame.height - totalHeight)/2
					targetFrame1.size.height = frame1ContentSize.height
					
					targetFrame2.origin.y = targetFrame1.minY + frame1ContentSize.height + space
					targetFrame2.size.height = frame2ContentSize.height
				}
				break
			}
		}
		
		targetFrame1 = targetFrame1.offsetBy(dx: translationOffset.x, dy: translationOffset.y)
		targetFrame2 = targetFrame2.offsetBy(dx: translationOffset.x, dy: translationOffset.y)
		
		frameLayout1.frame = targetFrame1.integral
		frameLayout2.frame = targetFrame2.integral
	}
	
}



================================================
FILE: FrameLayoutKit/Classes/FlowFrameLayout.swift
================================================
//
//  FlowFrameLayout.swift
//  FrameLayoutKit
//
//  Created by Nam Kennic on 11/18/20.
//

import UIKit

open class FlowFrameLayout: FrameLayout {
	public var axis: NKLayoutAxis = .horizontal {
		didSet {
			stackLayout.axis = axis == .horizontal ? .vertical : .horizontal
			setNeedsLayout()
		}
	}
	
	public var distribution: NKLayoutDistribution = .left {
		didSet { setNeedsLayout() }
	}
	
	public override var isIntrinsicSizeEnabled: Bool {
		get { stackLayout.isIntrinsicSizeEnabled }
		set {
			stackLayout.isIntrinsicSizeEnabled = newValue
			setNeedsLayout()
		}
	}
	
	override public var edgeInsets: UIEdgeInsets {
		get { stackLayout.edgeInsets }
		set {
			stackLayout.edgeInsets = newValue
			setNeedsLayout()
		}
	}
	
	override public var minSize: CGSize {
		didSet {
			stackLayout.minSize = minSize
			setNeedsLayout()
		}
	}
	
        override public var maxSize: CGSize {
                didSet {
                        stackLayout.maxSize = maxSize
                        setNeedsLayout()
                }
        }
	
	override public var fixedSize: CGSize {
		didSet {
			stackLayout.fixedSize = fixedSize
			setNeedsLayout()
		}
	}
	
	override public var heightRatio: CGFloat {
		didSet {
			stackLayout.heightRatio = heightRatio
			setNeedsLayout()
		}
	}
	
	override public var debug: Bool {
		didSet { stackLayout.debug = debug }
	}
	
	override public var debugColor: UIColor? {
		didSet { stackLayout.debugColor = debugColor }
	}
	
	public var isJustified: Bool = false {
		didSet { setNeedsLayout() }
	}
	
	public var lineSpacing: CGFloat {
		get { stackLayout.spacing }
		set {
			stackLayout.spacing = newValue
			setNeedsLayout()
		}
	}
	
	public var interItemSpacing: CGFloat = 0 {
		didSet {
			stackLayout.frameLayouts.filter { $0 is StackFrameLayout }.forEach { ($0 as? StackFrameLayout)?.spacing = interItemSpacing }
			setNeedsLayout()
		}
	}
	
	/*
	public override var isUserInteractionEnabled: Bool {
		didSet {
			stackLayout.frameLayouts.forEach { $0.isUserInteractionEnabled = isUserInteractionEnabled }
		}
	}
	*/
	
	public var stackCount: Int { stackLayout.frameLayouts.count }
	public var stacks: [StackFrameLayout] { stackLayout.frameLayouts as? [StackFrameLayout] ?? [] }
	public var firstStack: StackFrameLayout? { stackLayout.firstFrameLayout as? StackFrameLayout }
	public var lastStack: StackFrameLayout? { stackLayout.lastFrameLayout as? StackFrameLayout }
	
	let stackLayout = ScrollStackView(axis: .vertical, distribution: .top)
	
	fileprivate var lastSize: CGSize = .zero
	public fileprivate(set) var viewCount: Int = 0
	
	/// Array of views that needs to be filled in this flow layout
	public var views: [UIView] = [] {
		didSet {
			lastSize = .zero
			viewCount = views.count
			setNeedsLayout()
		}
	}
	
	/// This block will be called when a new StackFrameLayout was added to a new row
	public var onNewStackBlock: ((FlowFrameLayout, StackFrameLayout) -> Void)? = nil
	
	/// This block will be called when a new StackFrameLayout was added to a new row
	public func onNewStackBlock(_ block: @escaping (_ flowLayout: FlowFrameLayout, _ addedStack: StackFrameLayout) -> Void) -> Self {
		onNewStackBlock = block
		return self
	}
	// MARK: -
	
	public convenience init(axis: NKLayoutAxis) {
		self.init()
		self.axis = axis
	}
	
	public required init() {
		super.init()
		
		axis = .horizontal
		isIntrinsicSizeEnabled = true
		stackLayout.scrollView.clipsToBounds = true
		
		addSubview(stackLayout)
	}
	
	public required init?(coder aDecoder: NSCoder) {
		super.init(coder: aDecoder)
	}
	
	// MARK: -
	
	@discardableResult
	public func add(_ view: UIView) -> UIView {
		views.append(view)
		setNeedsLayout()
		return view
	}
	
	public func removeFirst() {
		views.removeFirst()
		setNeedsLayout()
	}
	
	public func removeLast() {
		views.removeLast()
		setNeedsLayout()
	}
	
	public func remove(at index: Int) {
		views.remove(at: index)
		setNeedsLayout()
	}
	
	public func removeAll() {
		views.removeAll()
		setNeedsLayout()
	}
	
	public func viewAt(row: Int, column: Int) -> UIView? {
		return frameLayout(row: row, column: column)?.targetView
	}
	
	public func viewsAt(stack: Int) -> [UIView]? {
		return stacks(at: stack)?.frameLayouts.compactMap { $0.targetView }
	}
	
	public func stacks(at index: Int) -> StackFrameLayout? {
		guard index > -1, index < stackLayout.frameLayouts.count, let frameLayout = stackLayout.frameLayouts[index] as? StackFrameLayout else { return nil }
		return frameLayout
	}
	
	public func frameLayout(row: Int, column: Int) -> FrameLayout? {
		guard row > -1, row < stackLayout.frameLayouts.count else { return nil }
		guard let rowLayout = stackLayout.frameLayouts[row] as? StackFrameLayout else { return nil }
		return rowLayout.frameLayout(at: column)
	}
	
	public func allFrameLayouts() -> [FrameLayout] {
		return stackLayout.frameLayouts.compactMap { $0 as? StackFrameLayout }.flatMap { $0.frameLayouts }
	}
	
	public func lastFrameLayout(containsView: Bool = false) -> FrameLayout? {
		guard let lastStack = lastStack else { return nil }
		
		if containsView {
			return lastStack.frameLayouts.last(where: { $0.targetView != nil })
		}
		else {
			return lastStack.frameLayouts.last
		}
	}
	
	// MARK: -
	
	fileprivate func newStack() -> StackFrameLayout {
		let layout = StackFrameLayout(axis: axis, distribution: distribution)
		layout.spacing = axis == .horizontal ? interItemSpacing : lineSpacing
		layout.isJustified = isJustified
		layout.debug = debug
		layout.parent = self
		
		return layout
	}
	
	/**
	Returns size that fits and map of number of items per row
	- parameter fitSize: Size that needs to be fit in
	- returns Size that fits all contents, and map of number of items per row, format: `[row: numberOfItems]`
	*/
	public func calculateSize(fitSize: CGSize) -> (size: CGSize, map: [Int: Int]) {
		var result = CGSize.zero
		var sizeMap = [Int: Int]()
		
		let verticalEdgeValues = edgeInsets.left + edgeInsets.right
		let horizontalEdgeValues = edgeInsets.top + edgeInsets.bottom
		let lastView = views.last
		
		if minSize == maxSize && minSize.width > 0 && minSize.height > 0 {
			result = minSize
		}
		else if heightRatio > 0 && !isIntrinsicSizeEnabled {
			result.height = result.width * heightRatio
		}
		else {
			let fitSize = CGSize(width: max(fitSize.width - verticalEdgeValues, 0), height: max(fitSize.height - horizontalEdgeValues, 0))
			
			if axis == .horizontal {
				var rowHeight: CGFloat = 0.0
				var row = 1
				var col = 1
				var remainingSize = fitSize
				var previousRowHeight: CGFloat?
				
				for view in views {
					if view.isHidden && ignoreHiddenView { continue }
					
					if remainingSize.width > 0 {
						let contentSize = view.sizeThatFits(remainingSize)
						let space = contentSize.width > 0 ? contentSize.width + (view != lastView ? interItemSpacing : 0) : 0
						remainingSize.width -= space
						rowHeight = max(rowHeight, contentSize.height)
						
						if col > 1 && previousRowHeight != nil && contentSize.height > previousRowHeight! {
							remainingSize.width = -1 // to trigger the following block
						}
						
						if row == 1 {
							previousRowHeight = rowHeight
						}
					}
					else if remainingSize.width == 0 {
						rowHeight = 0
						remainingSize.width -= 1 // to trigger the following block
					}
					
					result.width = max(result.width, fitSize.width - remainingSize.width)
					
					if remainingSize.width < 0, col > 1 {
						remainingSize.width = fitSize.width
						remainingSize.height -= result.height
						
						let contentSize = view.sizeThatFits(remainingSize)
						let space = contentSize.width > 0 ? contentSize.width + (view != lastView ? interItemSpacing : 0) : 0
						remainingSize.width -= space
						
						rowHeight = max(contentSize.height, 0)
						if rowHeight > 0 {
							result.height += (lineSpacing + rowHeight)
							previousRowHeight = rowHeight
						}
						
						row += 1
						col = 1
					}
					
					sizeMap[row] = col
					result.height = max(result.height, rowHeight)
					
					col += 1
				}
			}
			else { // axis = .vertical
				let fitSize = CGSize(width: fitSize.width, height: maxHeight <= 0 ? 32_000 : maxHeight)
				var colWidth: CGFloat = 0.0
				var row = 1
				var col = 1
				var remainingSize = fitSize
				
				for view in views {
					if view.isHidden && ignoreHiddenView { continue }
					
					if remainingSize.height > 0 {
						let contentSize = view.sizeThatFits(remainingSize)
						let space = contentSize.height > 0 ? contentSize.height + (view != lastView ? lineSpacing : 0) : 0
						remainingSize.height -= space
						colWidth = max(colWidth, contentSize.width)
					}
					else if remainingSize.height == 0 {
						remainingSize.height -= 1 // to trigger the following block
					}
					
					result.height = max(result.height, fitSize.height - remainingSize.height)
					
					if remainingSize.height < 0, row > 1 {
						remainingSize.width -= result.width
						remainingSize.height = fitSize.height
						
						let contentSize = view.sizeThatFits(remainingSize)
						let space = contentSize.height > 0 ? contentSize.height + (view != lastView ? lineSpacing : 0) : 0
						remainingSize.height -= space
						
						colWidth = max(contentSize.width, 0)
						if colWidth > 0 { result.width += (interItemSpacing + colWidth) }
						
						col += 1
						row = 1
					}
					
					sizeMap[col] = row
					result.width = max(result.width, colWidth)
					
					row += 1
				}
			}
		}
		
		if result.width > 0 { result.width += verticalEdgeValues }
		if result.height > 0 { result.height += horizontalEdgeValues }
		
		if axis == .horizontal {
			result.width = min(result.width, fitSize.width)
		}
		else {
			result.height = min(result.height, fitSize.height)
		}
		
		return (result, sizeMap)
	}
	
	override open func sizeThatFits(_ size: CGSize) -> CGSize {
		if !isEnabled { return .zero }
		
		willSizeThatFitsBlock?(self, size)
		return calculateSize(fitSize: size).size.limitTo(minSize: minSize, maxSize: maxSize)
	}
	
	open override func layoutSubviews() {
		super.layoutSubviews()
		if !isEnabled { return }
		
		defer {
			didLayoutSubviewsBlock?(self)
		}
		
		let boundSize = bounds.size
		let contentSize = calculateSize(fitSize: boundSize)
		
		if lastSize != bounds.size {
			lastSize = bounds.size
			
			let map = contentSize.map
			stackLayout.removeAll()
			
			var index = 0
			let numberOfStack = map.keys.count
			for i in 0..<numberOfStack {
				if index == viewCount { break }
				
				let stack = newStack()
				let numberOfItems = map[i+1] ?? 0
				for _ in 0..<numberOfItems {
					if index == viewCount { break }
					let view = views[index]
					stack + view
					index += 1
				}
				
				stackLayout + stack
				onNewStackBlock?(self, stack)
			}
		}
		
		stackLayout.frame = bounds
	}
	
}



================================================
FILE: FrameLayoutKit/Classes/FLSkeletonView.swift
================================================
//
//  FLSkeletonView.swift
//  FrameLayoutKit
//
//  Created by Nam Kennic on 9/3/23.
//

import UIKit

public class FLSkeletonView: UIView {
	let gradient = CAGradientLayer()
	let lightLayer = CAShapeLayer()
	let animation = CABasicAnimation(keyPath: "locations")
	
	public override var backgroundColor: UIColor? {
		didSet {
			lightLayer.fillColor = UIColor.lightText.cgColor
		}
	}
	
	init() {
		super.init(frame: .zero)
		
		layer.cornerRadius = 5
		layer.masksToBounds = true
		layer.addSublayer(lightLayer)
		
		let light = UIColor.clear.cgColor
		let dark = UIColor.black.cgColor
		
		gradient.colors = [dark, light, dark]
		gradient.startPoint = CGPoint(x: 0.0, y: 0.5)
		gradient.endPoint = CGPoint(x: 1.0, y: 0.525)
		gradient.locations = [0.4, 0.5, 0.6]
		lightLayer.mask = gradient
		
		animation.fromValue = [0.0, 0.1, 0.2]
		animation.toValue = [0.8, 0.9, 1.0]
	}
	
	required init?(coder aDecoder: NSCoder) {
		fatalError("init(coder:) has not been implemented")
	}
	
	public override func didMoveToSuperview() {
		if superview != nil {
			startShimmering()
		}
		else {
			stopShimmering()
		}
	}
	
	public func startShimmering(duration: TimeInterval = 1.0, repeatCount: Float = HUGE, repeatDuration: TimeInterval = 0) {
		animation.duration = duration
		animation.repeatCount = repeatCount
		animation.repeatDuration = repeatDuration
		gradient.add(animation, forKey: "shimmer")
	}
	
	public func stopShimmering() {
		layer.mask?.removeAllAnimations()
		layer.mask = nil
	}
	
	public override func layoutSubviews() {
		super.layoutSubviews()
		
		lightLayer.path = UIBezierPath(roundedRect: bounds, cornerRadius: layer.cornerRadius).cgPath
		lightLayer.frame = bounds
		gradient.frame = CGRect(x: -bounds.size.width, y: 0, width: 3 * bounds.size.width, height: bounds.size.height)
	}
	
	deinit {
		stopShimmering()
	}

}



================================================
FILE: FrameLayoutKit/Classes/FLView.swift
================================================
//
//  FLView.swift
//  FrameLayoutKit
//
//  Created by Nam Kennic on 10/16/21.
//

import UIKit

open class FLView<T: FrameLayout>: UIView {
	public let frameLayout = T()
	
	override open func sizeThatFits(_ size: CGSize) -> CGSize {
		return frameLayout.sizeThatFits(size)
	}
	
	override open func layoutSubviews() {
		super.layoutSubviews()
		frameLayout.frame = bounds
	}
	
}



================================================
FILE: FrameLayoutKit/Classes/FrameLayout.swift
================================================
//
//  FrameLayout.swift
//  FrameLayoutKit
//
//  Created by Nam Kennic on 7/12/18.
//

import UIKit
import CoreGraphics

public enum NKContentVerticalAlignment {
	case center
	case top
	case bottom
	case fill
	case fit
}

public enum NKContentHorizontalAlignment {
	case center
	case left
	case right
	case fill
	case fit
}

/**
FrameLayout is the fundamental component of the kit. This class will automatically adjust the size and position of the view assigned to it based on the size and position of the frameLayout itself, and the specified alignment value.
*/
open class FrameLayout: UIView {
       /// Show warnings on debug console when adding a UIControl without `isUserInteractionEnabled` turned on, which will make that control untouchable
	public static var showDebugWarnings = false
	
	/// Target view that handled by this frameLayout
	public var targetView: UIView?
	/// Additional views that will have their frames binding to `targetView`'s frame
	public var bindingViews: [UIView]?
	/// edgeInsets that will be applied to binding views
	public var bindingEdgeInsets: UIEdgeInsets = .zero
	/// other views that will be binded to this frame
	public var lazyBindingViews: (() -> [UIView?]?)?
	/// FrameLayout that contains this
	public weak var parent: FrameLayout?
	/// If set to `true`, `sizeThatFits(size:)` will returns `.zero` if `targetView` is hidden.
	public var ignoreHiddenView = true
	/// If set to `false`, it will return .zero in sizeThatFits and ignore running layoutSubviews. It will also ignore `willSizeThatFits` and `willLayoutSubviews` blocks.
	public var isEnabled = true {
		didSet { skeletonView?.isHidden = targetView == nil || !isEnabled || isEmpty }
	}
	/// Padding edge insets
	public var edgeInsets: UIEdgeInsets = .zero
	/// Add translation position to view
	public var translationOffset: CGPoint = .zero
	/// Add x translation to view
	public var translationX: CGFloat {
		get { translationOffset.x }
		set {
			translationOffset.x = newValue
			setNeedsLayout()
		}
	}
	/// Add y translation to view
	public var translationY: CGFloat {
		get { translationOffset.y }
		set {
			translationOffset.y = newValue
			setNeedsLayout()
		}
	}
	/// Minimum size of this frameLayout
	public var minSize: CGSize = .zero
	/// Mininum width of this frameLayout
	public var minWidth: CGFloat {
		get { minSize.width }
		set { minSize.width = newValue }
	}
	/// Mininum height of this frameLayout
	public var minHeight: CGFloat {
		get { minSize.height }
		set { minSize.height = newValue }
	}
	/// Maximum size of frameLayout
	public var maxSize: CGSize = .zero
	/// Maximum width of this frameLayout
	public var maxWidth: CGFloat {
		get { maxSize.width }
		set { maxSize.width = newValue }
	}
	/// Maximum height of this frameLayout
	public var maxHeight: CGFloat {
		get { maxSize.height }
		set { maxSize.height = newValue }
	}
	/// Minimum size of `targetView`
	public var minContentSize: CGSize = .zero
	/// Mininum width of `targetView`
	public var minContentWidth: CGFloat {
		get { minContentSize.width }
		set { minContentSize.width = newValue }
	}
	/// Mininum height of `targetView`
	public var minContentHeight: CGFloat {
		get { minContentSize.height }
		set { minContentSize.height = newValue }
	}
	/// Maximum size of targetView
	public var maxContentSize: CGSize = .zero
	/// Maximum width of `targetView`
	public var maxContentWidth: CGFloat {
		get { maxContentSize.width }
		set { maxContentSize.width = newValue }
	}
	/// Maximum height of `targetView`
	public var maxContentHeight: CGFloat {
		get { maxContentSize.height }
		set { maxContentSize.height = newValue }
	}
	/// Adding size to content size. `minSize` and `maxSize` is still the limitation.
	public var extendSize: CGSize = .zero
	/// Extending width to content size
	public var extendWidth: CGFloat {
		get { extendSize.width }
		set { extendSize.width = newValue }
	}
	/// Extending height to content size
	public var extendHeight: CGFloat {
		get { extendSize.height }
		set { extendSize.height = newValue }
	}
	/// Width of `targetView` will be stretched out to fill frameLayout if the width of this frameLayout is larger than `targetView`'s width
	public var allowContentVerticalGrowing = false
	/// Width of `targetView` will be shrinked down to fit frameLayout if the width of this frameLayout is smaller than `targetView`'s width
	public var allowContentVerticalShrinking = false
	/// Height of `targetView` will be stretched out to fill frameLayout if the height of this frameLayout is larger than `targetView`'s height
	public var allowContentHorizontalGrowing = false
	/// Height of `targetView` will be shrinked down to fit frameLayout if the height of this frameLayout is smaller than `targetView`'s height
	public var allowContentHorizontalShrinking = false
	/// Value of `sizeThatFits` will be cached based on `targetView`'s memory address. This is not proved for better performance, use it with care. Default is `false`
	public var shouldCacheSize = false
	/// Make it flexible in a `StackFrameLayout`, that means when it was added to a stack, this flexible stack will be stretched base on the stack size
	public var isFlexible = false
	/// Ratio used in `StackFrameLayout` when `isFlexible` = true. Default value is auto (`-1`)
	public var flexibleRatio: CGFloat = -1
	/// if `true`, `sizeThatFits` will returns the intrinsic width of `targetView`
	public var isIntrinsicSizeEnabled = true
	/// Returns height from `sizeThatFits` base on ratio of width. For example setting `1.0` will returns a square size from `sizeThatFits`
	public var heightRatio: CGFloat = 0 {
		didSet {
			if heightRatio > 0 {
				isIntrinsicSizeEnabled = false
			}
		}
	}
	
	/// Show the dash line of the frameLayout for debugging. This works in development mode only, released version will ignore this
	public var debug: Bool = false {
		didSet {
			#if DEBUG
			setNeedsDisplay()
			#endif
		}
	}
	
	/// Set the color of debug line
	public var debugColor: UIColor? = nil {
		didSet {
			#if DEBUG
			setNeedsDisplay()
			#endif
		}
	}
	
	/// Set the fixed size of frameLayout
	public var fixedSize: CGSize = .zero {
		didSet {
			minSize = fixedSize
			maxSize = fixedSize
		}
	}
	
	public var fixedWidth: CGFloat {
		get { fixedSize.width }
		set { fixedSize.width = newValue }
	}
	
	public var fixedHeight: CGFloat {
		get { fixedSize.height }
		set { fixedSize.height = newValue }
	}
	
	/// Set the fixed size of targetView
	public var fixedContentSize: CGSize = .zero {
		didSet {
			minContentSize = fixedContentSize
			maxContentSize = fixedContentSize
		}
	}
	
	/// Set fixed width of targetView
	public var fixedContentWidth: CGFloat {
		get { fixedContentSize.width }
		set { fixedContentSize.width = newValue }
	}
	
	/// Set fixed height of targetView
	public var fixedContentHeight: CGFloat {
		get { fixedContentSize.height }
		set { fixedContentSize.height = newValue }
	}
	
	/// Set the alignment of both axis
	public var alignment: (vertical: NKContentVerticalAlignment, horizontal: NKContentHorizontalAlignment) = (.fill, .fill)
	
	/// Block will be called before calling sizeThatFits
	public var willSizeThatFitsBlock: ((FrameLayout, CGSize) -> Void)?
	/// Block will be called before calling layoutSubviews
	public var willLayoutSubviewsBlock: ((FrameLayout) -> Void)?
	/// Block will be called after layoutSubviews finished
	public var didLayoutSubviewsBlock: ((FrameLayout) -> Void)?
	
	override open var frame: CGRect {
		get { super.frame }
		set {
			if newValue.isInfinite || newValue.isNull || newValue.minX.isNaN || newValue.minY.isNaN || newValue.width.isNaN || newValue.height.isNaN { return }
			
			super.frame = newValue
			setNeedsLayout()
			
			#if DEBUG
			if debug {
				setNeedsDisplay()
			}
			#endif
			
			if superview == nil {
				layoutIfNeeded()
			}
		}
	}
	
	override open var bounds: CGRect {
		get { super.bounds }
		set {
			if newValue.isInfinite || newValue.isNull || newValue.minX.isNaN || newValue.minY.isNaN || newValue.width.isNaN || newValue.height.isNaN { return }
			
			super.bounds = newValue
			setNeedsLayout()
			
			#if DEBUG
			if debug {
				setNeedsDisplay()
			}
			#endif
			
			if superview == nil {
				layoutIfNeeded()
			}
		}
	}
	
	open override var description: String {
		return "[\(super.description)]-targetView: \(String(describing: targetView))"
	}
	
	lazy fileprivate var sizeCacheData: [String: CGSize] = {
		return [:]
	}()
	
	/// Returns `true` if `targetView` is nil or hidden. And if `ignoreHiddenView` is `true`
	public var isEmpty: Bool {
		return ((targetView?.isHidden ?? false || isHidden) && ignoreHiddenView)
	}
	
	/// Returns intrinsic content size
	open override var intrinsicContentSize: CGSize {
#if os(visionOS)
		let scenes = UIApplication.shared.connectedScenes
		let windowScene = scenes.first as? UIWindowScene
		let window = windowScene?.windows.first
		let width: CGFloat = window?.bounds.width ?? 0
		return contentSizeThatFits(size: CGSize(width: width, height: .greatestFiniteMagnitude))
#else
		return contentSizeThatFits(size: CGSize(width: UIScreen.main.nativeBounds.width, height: .greatestFiniteMagnitude))
#endif
	}
	
	// Skeleton
	
	public var skeletonView: FLSkeletonView?
	/// set color for skeleton mode
	public var skeletonColor: UIColor = UIColor(white: 0.8, alpha: 1.0)
	public var skeletonMinSize: CGSize = .zero
	public var skeletonMaxSize: CGSize = .zero
	public var isSkeletonMode: Bool = false {
		didSet {
			if isSkeletonMode {
				skeletonView = FLSkeletonView()
				skeletonView!.backgroundColor = skeletonColor
				addSubview(skeletonView!)
				setNeedsLayout()
			}
			else {
				skeletonView?.removeFromSuperview()
				skeletonView = nil
			}
		}
	}
	
	// MARK: -
	
	@discardableResult
	public convenience init(_ block: (FrameLayout) throws -> Void) rethrows {
		self.init()
		try block(self)
	}
	
	convenience public init(targetView: UIView? = nil) {
		self.init()
		self.targetView = targetView
	}
	
	public required init() {
		super.init(frame: .zero)
		
		backgroundColor = .clear
		isUserInteractionEnabled = false
		isIntrinsicSizeEnabled = true
	}
	
	public required init?(coder aDecoder: NSCoder) {
		super.init(coder: aDecoder)
	}
		
	#if DEBUG
	override open func draw(_ rect: CGRect) {
		guard debug, !isEmpty, bounds != .zero else {
			super.draw(rect)
			return
		}
		
		if debugColor == nil {
			debugColor = randomColor()
		}
		
		guard let context = UIGraphicsGetCurrentContext() else { return }
		context.saveGState()
		context.setStrokeColor(debugColor!.cgColor)
		context.setLineDash(phase: 0, lengths: [4.0, 2.0])
		context.stroke(bounds)
		context.restoreGState()
	}
	
	fileprivate func randomColor() -> UIColor {
		let colors: [UIColor] = [.red, .green, .blue, .brown, .gray, .yellow, .magenta, .black, .orange, .purple, .cyan]
		let randomIndex = Int(arc4random()) % colors.count
		return colors[randomIndex]
	}
	#endif
	
	open func sizeThatFits(_ size: CGSize, intrinsic: Bool = true) -> CGSize {
		isIntrinsicSizeEnabled = intrinsic
		return sizeThatFits(size)
	}
	
	override open func sizeThatFits(_ size: CGSize) -> CGSize {
		return sizeThatFits(size, ignoreHiddenView: ignoreHiddenView)
	}
	
	open func sizeThatFits(_ size: CGSize, ignoreHiddenView: Bool) -> CGSize {
		if !isEnabled { return .zero }
		
		willSizeThatFitsBlock?(self, size)
		if isEmpty && ignoreHiddenView { return .zero }
		
		if minSize == maxSize && minSize.width > 0 && minSize.height > 0 { return minSize }
		
		var result: CGSize = .zero
		let verticalEdgeValues = edgeInsets.left + edgeInsets.right
		let horizontalEdgeValues = edgeInsets.top + edgeInsets.bottom
		let contentSize = CGSize(width: max(size.width - verticalEdgeValues, 0), height: max(size.height - horizontalEdgeValues, 0))
		
		if heightRatio > 0 {
			result.width = isIntrinsicSizeEnabled ? contentSizeThatFits(size: contentSize).width : contentSize.width
			result.height = result.width * heightRatio
		}
		else {
			result = contentSizeThatFits(size: contentSize)
			
			if !isIntrinsicSizeEnabled {
				result.width = contentSize.width
			}
		}
		
		result.limitedTo(minSize: minSize, maxSize: maxSize)
		
		if result.width > 0 { result.width += verticalEdgeValues }
		if result.height > 0 { result.height += horizontalEdgeValues }
		
		result.width = min(result.width, size.width)
		result.height = min(result.height, size.height)
		
		return result
	}
	
	override open func layoutSubviews() {
		if !isEnabled { return }
		
		willLayoutSubviewsBlock?(self)
		super.layoutSubviews()
		
		defer {
			if let skeletonView {
				var skeletonFrame: CGRect = targetView != nil ? convert(targetView!.frame, from: targetView!.superview) : bounds.inset(by: edgeInsets)
				skeletonFrame.size.limitedTo(minSize: skeletonMinSize, maxSize: skeletonMaxSize)
				skeletonView.frame = skeletonFrame
				skeletonView.isHidden = targetView == nil || !isEnabled || isEmpty
			}
			
			didLayoutSubviewsBlock?(self)
		}
		
		guard let targetView = targetView, !bounds.isEmpty else {
			bindViews(to: self)
			return
		}
		
		var targetFrame: CGRect = .zero
		#if swift(>=4.2)
		let containerFrame = bounds.inset(by: edgeInsets)
		#else
		let containerFrame = UIEdgeInsetsInsetRect(bounds, edgeInsets)
		#endif
		let contentSize = (alignment.horizontal != .fill || alignment.vertical != .fill) || (minContentSize != .zero || maxContentSize != .zero) ? contentSizeThatFits(size: containerFrame.size) : .zero
		
		switch alignment.horizontal {
		case .left:
			if allowContentHorizontalGrowing {
				targetFrame.size.width = max(containerFrame.width, contentSize.width)
			}
			else {
				targetFrame.size.width = allowContentHorizontalShrinking ? min(containerFrame.width, contentSize.width) : contentSize.width
			}
			
			targetFrame.origin.x = containerFrame.minX
			break
			
		case .right:
			if allowContentHorizontalGrowing {
				targetFrame.size.width = max(containerFrame.width, contentSize.width)
			}
			else {
				targetFrame.size.width = allowContentHorizontalShrinking ? min(containerFrame.width, contentSize.width) : contentSize.width
			}
			
			targetFrame.origin.x = containerFrame.maxX - targetFrame.width
			break
			
		case .center:
			if allowContentHorizontalGrowing {
				targetFrame.size.width = max(containerFrame.width, contentSize.width)
			}
			else {
				targetFrame.size.width = allowContentHorizontalShrinking ? min(containerFrame.width, contentSize.width) : contentSize.width
			}
			
			targetFrame.origin.x = containerFrame.minX + (containerFrame.width - targetFrame.width) / 2
			break
			
		case .fill:
			targetFrame.origin.x = containerFrame.minX
			targetFrame.size.width = containerFrame.width
			break
			
		case .fit:
			if allowContentHorizontalGrowing {
				targetFrame.size.width = max(containerFrame.width, contentSize.width)
			}
			else {
				targetFrame.size.width = min(containerFrame.width, contentSize.width)
			}
			
			targetFrame.origin.x = containerFrame.minX + (containerFrame.width - targetFrame.width) / 2
			break
		}
		
		switch alignment.vertical {
		case .top:
			if allowContentVerticalGrowing {
				targetFrame.size.height = max(containerFrame.height, contentSize.height)
			}
			else if allowContentVerticalShrinking {
				targetFrame.size.height = min(containerFrame.height, contentSize.height)
			}
			else {
				targetFrame.size.height = contentSize.height
			}
			
			targetFrame.origin.y = containerFrame.minY
			break
		
		case .bottom:
			if allowContentVerticalGrowing {
				targetFrame.size.height = max(containerFrame.height, contentSize.height)
			}
			else if allowContentVerticalShrinking {
				targetFrame.size.height = min(containerFrame.height, contentSize.height)
			}
			else {
				targetFrame.size.height = contentSize.height
			}
			
			targetFrame.origin.y = containerFrame.maxY - contentSize.height
			break
			
		case .center:
			if allowContentVerticalGrowing {
				targetFrame.size.height = max(containerFrame.height, contentSize.height)
			}
			else if allowContentVerticalShrinking {
				targetFrame.size.height = min(containerFrame.height, contentSize.height)
			}
			else {
				targetFrame.size.height = contentSize.height
			}
			
			targetFrame.origin.y = containerFrame.minY + (containerFrame.height - contentSize.height) / 2
			break
			
		case .fill:
			targetFrame.origin.y = containerFrame.minY
			targetFrame.size.height = containerFrame.height
			break
			
		case .fit:
			if allowContentVerticalGrowing {
				targetFrame.size.height = max(containerFrame.height, contentSize.height)
			}
			else {
				targetFrame.size.height = min(containerFrame.height, contentSize.height)
			}
			
			targetFrame.origin.y = containerFrame.minY + (containerFrame.height - targetFrame.height) / 2
			break
		}
		
		targetFrame.size.limitedTo(minSize: minContentSize, maxSize: maxContentSize)
		targetFrame = targetFrame.integral
		targetFrame = targetFrame.offsetBy(dx: translationOffset.x, dy: translationOffset.y)
		
		if targetView.superview == self {
			targetView.frame = targetFrame
		}
		else {
			if superview == nil || window == nil  {
				targetFrame.origin.x = frame.minX
				targetFrame.origin.y = frame.minY
				
				var superView: UIView? = superview
				while superView != nil && (superView is FrameLayout) {
					targetFrame.origin.x += superView!.frame.minX
					targetFrame.origin.y += superView!.frame.minY
					superView = superView!.superview
				}
				
				targetView.frame = targetFrame.offsetBy(dx: translationOffset.x, dy: translationOffset.y)
			}
			else {
				targetView.frame = convert(targetFrame, to: targetView.superview)
			}
		}
		
		bindViews(to: targetView)
	}
	
	func bindViews(to targetView: UIView) {
		var bindViews = bindingViews ?? []
		if let views = lazyBindingViews?() { bindViews.append(contentsOf: views.compactMap {$0}) }
		guard !bindViews.isEmpty else { return }
#if swift(>=4.2)
		let targetFrame = targetView.frame.inset(by: bindingEdgeInsets)
#else
		let targetFrame = UIEdgeInsetsInsetRect(targetView.frame, bindingEdgeInsets)
#endif
		bindViews.forEach {
			if $0.superview == targetView {
				$0.frame = CGRect(origin: .zero, size: targetFrame.size)
			}
			else if $0.superview != targetView.superview, let superView1 = $0.superview, let superView2 = targetView.superview {
				$0.frame = superView2.convert(targetFrame, to: superView1)
			}
			else {
				$0.frame = targetFrame
			}
		}
	}
	
	open override func didMoveToWindow() {
		super.didMoveToWindow()
		setNeedsLayout()
	}
	
	open override func didMoveToSuperview() {
		super.didMoveToSuperview()
		setNeedsLayout()
	}
	
	override open func setNeedsLayout() {
		super.setNeedsLayout()
		targetView?.setNeedsLayout()
	}
	
	override open func layoutIfNeeded() {
		super.layoutIfNeeded()
		targetView?.layoutIfNeeded()
	}
	
	// MARK: -
	
	fileprivate func addressOf<T: AnyObject>(_ o: T) -> String {
		let addr = unsafeBitCast(o, to: Int.self)
		return String(format: "%p", addr)
	}
	
	fileprivate func contentSizeThatFits(size: CGSize) -> CGSize {
		guard let targetView = targetView else { return .zero }
		
		if minContentSize == maxContentSize && minContentSize.width > 0 && minContentSize.height > 0 { return minContentSize }
		
		var result: CGSize
		
		if minSize == maxSize && minSize.width > 0 && minSize.height > 0 {
			result = minSize // fixedSize
		}
		else {
			if shouldCacheSize {
				let key = "\(addressOf(targetView))_\(size)"
				if let value = sizeCacheData[key] {
					return value
				}
				else {
					result = targetView.sizeThatFits(size)
					sizeCacheData[key] = result
				}
			}
			else {
				result = targetView.sizeThatFits(size)
			}
			
			result.width += extendSize.width
			result.height += extendSize.height
			
			result.limitedTo(minSize: minSize, maxSize: maxSize)
		}
		
		result.limitedTo(minSize: minContentSize, maxSize: maxContentSize)
		return result
	}
	
}



================================================
FILE: FrameLayoutKit/Classes/GridFrameLayout.swift
================================================
//
//  GridFrameLayout.swift
//  FrameLayoutKit
//
//  Created by Nam Kennic on 5/8/20.
//

import UIKit

open class GridFrameLayout: FrameLayout {
	public var axis: NKLayoutAxis = .horizontal {
		didSet {
			arrangeViews()
		}
	}
	
	/// Auto set number of columns or rows base on its size
	public var isAutoSize = false
	
	/*
	public override var isUserInteractionEnabled: Bool {
		didSet {
			stackLayout.frameLayouts.forEach { $0.isUserInteractionEnabled = isUserInteractionEnabled }
		}
	}
	*/
	
	public override var isIntrinsicSizeEnabled: Bool {
		get { stackLayout.isIntrinsicSizeEnabled }
		set {
			stackLayout.isIntrinsicSizeEnabled = newValue
			setNeedsLayout()
		}
	}
	
	override public var edgeInsets: UIEdgeInsets {
		get { stackLayout.edgeInsets }
		set {
			stackLayout.edgeInsets = newValue
			setNeedsLayout()
		}
	}
	
	override public var minSize: CGSize {
		didSet {
			stackLayout.minSize = minSize
			setNeedsLayout()
		}
	}
	
        override public var maxSize: CGSize {
                didSet {
                        stackLayout.maxSize = maxSize
                        setNeedsLayout()
                }
        }
	
	override public var fixedSize: CGSize {
		didSet {
			stackLayout.fixedSize = fixedSize
			setNeedsLayout()
		}
	}
	
	public var minRowHeight: CGFloat = 0 {
		didSet {
			stackLayout.frameLayouts.forEach { $0.minSize = CGSize(width: $0.minSize.width, height: minRowHeight) }
			setNeedsLayout()
		}
	}
	
	public var maxRowHeight: CGFloat = 0 {
		didSet {
			stackLayout.frameLayouts.forEach { $0.maxSize = CGSize(width: $0.maxSize.width, height: maxRowHeight) }
			setNeedsLayout()
		}
	}
	
	public var fixedRowHeight: CGFloat = 0 {
		didSet {
			stackLayout.frameLayouts.forEach { $0.fixedSize = CGSize(width: $0.fixedSize.width, height: fixedRowHeight) }
			setNeedsLayout()
		}
	}
	
	public var minColumnWidth: CGFloat = 0 {
		didSet {
			stackLayout.frameLayouts.filter { $0 is StackFrameLayout }.forEach { $0.minSize = CGSize(width: minColumnWidth, height: $0.minSize.height) }
			setNeedsLayout()
		}
	}
	
	public var maxColumnWidth: CGFloat = 0 {
		didSet {
			stackLayout.frameLayouts.filter { $0 is StackFrameLayout }.forEach { $0.maxSize = CGSize(width: maxColumnWidth, height: $0.maxSize.height) }
			setNeedsLayout()
		}
	}
	
	public var fixedColumnWidth: CGFloat = 0 {
		didSet {
			stackLayout.frameLayouts.filter { $0 is StackFrameLayout }.forEach { $0.fixedSize = CGSize(width: fixedColumnWidth, height: $0.fixedSize.height) }
			setNeedsLayout()
		}
	}
	
	override public var heightRatio: CGFloat {
		didSet {
			stackLayout.heightRatio = heightRatio
			setNeedsLayout()
		}
	}
	
	override public var debug: Bool {
		didSet { stackLayout.debug = debug }
	}
	
	override public var debugColor: UIColor? {
		didSet { stackLayout.debugColor = debugColor }
	}
	
	public var verticalSpacing: CGFloat {
		get { stackLayout.spacing }
		set {
			stackLayout.spacing = newValue
			setNeedsLayout()
		}
	}
	
	public var horizontalSpacing: CGFloat = 0 {
		didSet {
			stackLayout.frameLayouts.filter { $0 is StackFrameLayout }.forEach { ($0 as? StackFrameLayout)?.spacing = horizontalSpacing }
			setNeedsLayout()
		}
	}
	
	// Skeleton
	
	/// set color for skeleton mode
	override public var skeletonColor: UIColor {
		didSet {
			stackLayout.skeletonColor = skeletonColor
		}
	}
	override public var skeletonMinSize: CGSize {
		didSet {
			stackLayout.skeletonMinSize = skeletonMinSize
		}
	}
	override public var skeletonMaxSize: CGSize {
		didSet {
			stackLayout.skeletonMaxSize = skeletonMaxSize
		}
	}
	override public var isSkeletonMode: Bool {
		didSet {
			stackLayout.isSkeletonMode = isSkeletonMode
			setNeedsLayout()
		}
	}
	
	// MARK: -
	
	public var rows: Int {
		get { stackLayout.frameLayouts.count }
		set {
			let count = stackLayout.frameLayouts.count
			
			if newValue == 0 {
				removeAllCells()
				return
			}
			
			if newValue < count {
				while stackLayout.frameLayouts.count > newValue {
					removeRow(at: stackLayout.frameLayouts.count - 1)
				}
			}
			else if newValue > count {
				while stackLayout.frameLayouts.count < newValue {
					addRow()
				}
			}
		}
	}
	
	private var initColumns: Int = 0
	public var columns: Int = 0 {
		didSet {
			stackLayout.frameLayouts.forEach { (layout) in
				if let layout = layout as? StackFrameLayout {
					layout.numberOfFrameLayouts = columns
					layout.frameLayouts.forEach {
						if fixedColumnWidth > 0 {
							$0.fixedSize = CGSize(width: fixedColumnWidth, height: $0.fixedSize.height)
						}
						else {
							$0.minSize = CGSize(width: minColumnWidth, height: $0.minSize.height)
							$0.maxSize = CGSize(width: maxColumnWidth, height: $0.maxSize.height)
						}
					}
				}
			}
		}
	}
	
	public fileprivate(set) var viewCount: Int = 0
	public var views: [UIView] = [] {
		didSet {
			views.forEach {
				if $0.superview == nil {
					addSubview($0)
				}
			}
			
			viewCount = views.count
			arrangeViews()
		}
	}
	
	public var firstRowLayout: StackFrameLayout? {
		return stackLayout.firstFrameLayout as? StackFrameLayout
	}
	
	public var lastRowLayout: StackFrameLayout? {
		return stackLayout.lastFrameLayout as? StackFrameLayout
	}
	
	let stackLayout = StackFrameLayout(axis: .vertical, distribution: .equal)
	
	// MARK: -
	
	public convenience init(axis: NKLayoutAxis, column: Int = 0, rows: Int = 0) {
		self.init()
		
		self.axis = axis
		defer {
			self.rows = rows
			self.columns = column
			self.initColumns = column
		}
	}
	
	public required init() {
		super.init()
		
		axis = .horizontal
		isIntrinsicSizeEnabled = true
		addSubview(stackLayout)
	}
	
	public required init?(coder aDecoder: NSCoder) {
		super.init(coder: aDecoder)
	}
	
	@discardableResult
	public init(_ block: (GridFrameLayout) throws -> Void) rethrows {
		super.init()
		try block(self)
	}
	
	// MARK: -
	
	public func viewAt(row: Int, column: Int) -> UIView? {
		return frameLayout(row: row, column: column)?.targetView
	}
	
	public func viewsAt(row: Int) -> [UIView]? {
		return rows(at: row)?.frameLayouts.compactMap( { return $0.targetView } )
	}
	
	public func viewsAt(column: Int) -> [UIView]? {
		var results = [UIView]()
		for r in 0..<rows {
			if let view = viewAt(row: r, column: column) {
				results.append(view)
			}
		}
		
		return results.isEmpty ? nil : results
	}
	
	public func rows(at index: Int) -> StackFrameLayout? {
		guard index > -1, index < stackLayout.frameLayouts.count, let frameLayout = stackLayout.frameLayouts[index] as? StackFrameLayout else { return nil }
		return frameLayout
	}
	
	public func frameLayout(row: Int, column: Int) -> FrameLayout? {
		guard row > -1, row < stackLayout.frameLayouts.count else { return nil }
		guard let rowLayout = stackLayout.frameLayouts[row] as? StackFrameLayout else { return nil }
		return rowLayout.frameLayout(at: column)
	}
	
	public func allFrameLayouts() -> [FrameLayout] {
		return stackLayout.frameLayouts.compactMap { $0 as? StackFrameLayout }.flatMap { $0.frameLayouts }
	}
	
	public func lastFrameLayout(containsView: Bool = false) -> FrameLayout? {
		guard let lastRows = lastRowLayout else { return nil }
		
		if containsView {
			return lastRows.frameLayouts.last(where: { $0.targetView != nil })
		}
		else {
			return lastRows.frameLayouts.last
		}
	}
	
	// MARK: -
	
	fileprivate func newRow() -> StackFrameLayout {
		let layout = StackFrameLayout(axis: .horizontal, distribution: .equal)
		layout.parent = self
		layout.numberOfFrameLayouts = columns
		layout.spacing = horizontalSpacing
		layout.debug = debug
		layout.isSkeletonMode = isSkeletonMode || layout.isSkeletonMode
		layout.skeletonColor = skeletonColor
		
		if fixedRowHeight > 0 {
			layout.fixedSize = CGSize(width: 0, height: fixedRowHeight)
		}
		else {
			layout.minSize = CGSize(width: 0, height: minRowHeight)
			layout.maxSize = CGSize(width: 0, height: maxRowHeight)
		}
		
		layout.frameLayouts.forEach {
			if fixedColumnWidth > 0 {
				$0.fixedSize = CGSize(width: fixedColumnWidth, height: $0.fixedSize.height)
			}
			else {
				$0.minSize = CGSize(width: minColumnWidth, height: $0.minSize.height)
				$0.maxSize = CGSize(width: maxColumnWidth, height: $0.maxSize.height)
			}
		}
		
		return layout
	}
	
	@discardableResult
	open func addRow() -> StackFrameLayout {
		let layout = newRow()
		stackLayout.add(layout)
		setNeedsLayout()
		return layout
	}
	
	@discardableResult
	open func insertRow(at index: Int, invert: Bool = false) -> StackFrameLayout {
		let layout = newRow()
		stackLayout.insert(layout, at: index, invert: invert)
		setNeedsLayout()
		return layout
	}
	
	open func removeRow(at index: Int) {
		stackLayout.removeFrameLayout(at: index)
		setNeedsLayout()
	}
	
	open func removeLastRow() {
		guard stackLayout.frameLayouts.count > 0 else { return }
		stackLayout.removeFrameLayout(at: stackLayout.frameLayouts.count - 1)
		setNeedsLayout()
	}
	
	// MARK: -
	
	open func addColumn() {
		stackLayout.frameLayouts.forEach {
			if let rowLayout = $0 as? StackFrameLayout {
				let row = rowLayout.add()
				row.debug = debug
				row.isSkeletonMode = isSkeletonMode || row.isSkeletonMode
				row.skeletonColor = skeletonColor
				
				if fixedColumnWidth > 0 {
					row.fixedSize = CGSize(width: fixedColumnWidth, height: fixedRowHeight)
				}
				else {
					row.minSize = CGSize(width: minColumnWidth, height: minRowHeight)
					row.maxSize = CGSize(width: maxColumnWidth, height: maxRowHeight)
				}
			}
		}
		setNeedsLayout()
	}
	
	open func insertColumn(at index: Int) {
		stackLayout.frameLayouts.forEach {
			if let rowLayout = $0 as? StackFrameLayout {
				let row = rowLayout.insert(nil, at: index)
				row.debug = debug
				row.isSkeletonMode = isSkeletonMode
				row.skeletonColor = skeletonColor
				
				if fixedColumnWidth > 0 {
					row.fixedSize = CGSize(width: fixedColumnWidth, height: fixedRowHeight)
				}
				else {
					row.minSize = CGSize(width: minColumnWidth, height: minRowHeight)
					row.maxSize = CGSize(width: maxColumnWidth, height: maxRowHeight)
				}
			}
		}
		setNeedsLayout()
	}
	
	open func removeColumn(at index: Int) {
		stackLayout.frameLayouts.forEach { ($0 as? StackFrameLayout)?.removeFrameLayout(at: index) }
		setNeedsLayout()
	}
	
	open func removeLastColumn() {
		stackLayout.frameLayouts.forEach {
			if let rowLayout = $0 as? StackFrameLayout {
				rowLayout.removeFrameLayout(at: rowLayout.frameLayouts.count - 1)
			}
		}
		setNeedsLayout()
	}
	
	open func removeAllCells() {
		stackLayout.removeAll()
	}
	
	// MARK: -
	
	func arrangeViews(autoColumns: Bool = true) {
		guard viewCount > 0 else { return }
		
		var numberOfRows = stackLayout.frameLayouts.count
		if isAutoSize {
			if axis == .horizontal, columns > 0 {
				let fitRows = max(Int(ceil(Double(viewCount) / Double(columns))), 1)
				if fitRows != rows {
					rows = fitRows
					numberOfRows = fitRows
				}
			}
			else if axis == .vertical, rows > 0 {
				let fitColumn = max(Int(ceil(Double(viewCount) / Double(rows))), 1)
				if fitColumn != columns {
					columns = fitColumn
				}
			}
		}
		
		var i: Int = 0
		
		if axis == .horizontal {
			if autoColumns, maxColumnWidth > 0 {
				var viewSize = stackLayout.bounds.size
				if viewSize == .zero { viewSize = bounds.size }
				let fitColumns = max(Int(viewSize.width / maxColumnWidth), max(initColumns, 1))
				if columns != fitColumns {
					columns = fitColumns
					arrangeViews(autoColumns: false)
					return
				}
			}
			
			for r in 0..<numberOfRows {
				guard let rowLayout = stackLayout.frameLayouts[r] as? StackFrameLayout else { continue }
				for c in 0..<rowLayout.frameLayouts.count {
					frameLayout(row: r, column: c)?.targetView = views[i]
					i += 1
					if i == viewCount { break }
				}
				if i == viewCount { break }
			}
		}
		else {
			for c in 0..<columns {
				for r in 0..<numberOfRows {
					frameLayout(row: r, column: c)?.targetView = views[i]
					i += 1
					if i == viewCount { break }
				}
				if i == viewCount { break }
			}
		}
		
		setNeedsLayout()
		layoutIfNeeded()
	}
	
	/**
	 This will set `isUserInteractionEnabled` as well as all sub-frameLayouts to the same value.
	 - parameter enabled: The name says it all
	 */
	@discardableResult
	public func setUserInteraction(enabled: Bool) -> Self {
		isUserInteractionEnabled = enabled
		stackLayout.frameLayouts.forEach { $0.isUserInteractionEnabled = enabled }
		return self
	}
	
	// MARK: -
	
	fileprivate var lastSize: CGSize = .zero
	open override func layoutSubviews() {
		super.layoutSubviews()
		if !isEnabled { return }
		
		if maxColumnWidth > 0, lastSize != bounds.size {
			lastSize = bounds.size
			arrangeViews()
		}
		
		if stackLayout.frame != bounds {
			stackLayout.frame = bounds
		}
	}
	
	open override func sizeThatFits(_ size: CGSize) -> CGSize {
		if !isEnabled { return .zero }
		return stackLayout.sizeThatFits(size)
	}
	
}



================================================
FILE: FrameLayoutKit/Classes/ScrollStackView.swift
================================================
//
//  ScrollStackView.swift
//  FrameLayoutKit
//
//  Created by Nam Kennic on 6/23/20.
//

import UIKit

open class ScrollStackView: UIView {
	
	open var views: [UIView] {
		get { frameLayouts.compactMap { $0.targetView } }
		set { _views = newValue }
	}
	
	fileprivate var _views: [UIView] = [] {
		didSet {
			updateLayout()
			setNeedsLayout()
		}
	}
	
	open var spacing: CGFloat {
		get { frameLayout.spacing }
		set {
			frameLayout.spacing = newValue
			setNeedsLayout()
		}
	}
	
	open var edgeInsets: UIEdgeInsets {
		get { frameLayout.edgeInsets }
		set {
			frameLayout.edgeInsets = newValue
			setNeedsLayout()
		}
	}
	
	open var isDirectionalLockEnabled: Bool {
		get { scrollView.isDirectionalLockEnabled }
		set {
			scrollView.isDirectionalLockEnabled = newValue
			setNeedsLayout()
		}
	}
	
	override open var frame: CGRect {
		didSet { setNeedsLayout() }
	}
	
	override open var bounds: CGRect {
		didSet { setNeedsLayout() }
	}
	
	public var axis: NKLayoutAxis {
		get { frameLayout.axis }
		set {
			frameLayout.axis = newValue
			setNeedsLayout()
		}
	}
	
	public var distribution: NKLayoutDistribution {
		get { frameLayout.distribution }
		set {
			frameLayout.distribution = newValue
			setNeedsLayout()
		}
	}
	
	public var debug: Bool {
		get { frameLayout.debug }
		set { frameLayout.debug = newValue }
	}
	
	public var debugColor: UIColor? {
		get { frameLayout.debugColor }
		set { frameLayout.debugColor = newValue }
	}
	
	public var isOverlapped: Bool {
		get { frameLayout.isOverlapped }
		set { frameLayout.isOverlapped = newValue }
	}
	
	public var fixedContentSize: CGSize {
		get { frameLayout.fixedContentSize }
		set {
			frameLayout.fixedContentSize = newValue
			setNeedsLayout()
		}
	}
	
	public var fixedContentWidth: CGFloat {
		get { frameLayout.fixedContentWidth }
		set {
			frameLayout.fixedContentWidth = newValue
			setNeedsLayout()
		}
	}
	
	public var fixedContentHeight: CGFloat {
		get { frameLayout.fixedContentHeight }
		set {
			frameLayout.fixedContentHeight = newValue
			setNeedsLayout()
		}
	}
	
	public var minContentSize: CGSize {
		get { frameLayout.minContentSize }
		set {
			frameLayout.minContentSize = newValue
			setNeedsLayout()
		}
	}
	
	public var minContentWidth: CGFloat {
		get { frameLayout.minContentWidth }
		set {
			frameLayout.minContentWidth = newValue
			setNeedsLayout()
		}
	}
	
	public var minContentHeight: CGFloat {
		get { frameLayout.minContentHeight }
		set {
			frameLayout.minContentHeight = newValue
			setNeedsLayout()
		}
	}
	
	public var maxContentSize: CGSize {
		get { frameLayout.maxContentSize }
		set {
			frameLayout.maxContentSize = newValue
			setNeedsLayout()
		}
	}
	
	public var maxContentWidth: CGFloat {
		get { frameLayout.maxContentWidth }
		set {
			frameLayout.maxContentWidth = newValue
			setNeedsLayout()
		}
	}
	
	public var maxContentHeight: CGFloat {
		get { frameLayout.maxContentHeight }
		set {
			frameLayout.maxContentHeight = newValue
			setNeedsLayout()
		}
	}
	
	public var minSize: CGSize {
		get { frameLayout.minSize }
		set {
			frameLayout.minSize = newValue
			setNeedsLayout()
		}
	}
	
	public var minWidth: CGFloat {
		get { frameLayout.minWidth }
		set {
			frameLayout.minWidth = newValue
			setNeedsLayout()
		}
	}
	
	public var minHeight: CGFloat {
		get { frameLayout.minHeight }
		set {
			frameLayout.minHeight = newValue
			setNeedsLayout()
		}
	}
	
	public var maxSize: CGSize {
		get { frameLayout.maxSize }
		set {
			frameLayout.maxSize = newValue
			setNeedsLayout()
		}
	}
	
	public var maxWidth: CGFloat {
		get { frameLayout.maxWidth }
		set {
			frameLayout.maxWidth = newValue
			setNeedsLayout()
		}
	}
	
	public var maxHeight: CGFloat {
		get { frameLayout.maxHeight }
		set {
			frameLayout.maxHeight = newValue
			setNeedsLayout()
		}
	}
	
	public var fixedSize: CGSize {
		get { frameLayout.fixedSize }
		set {
			frameLayout.fixedSize = newValue
			setNeedsLayout()
		}
	}
	
	public var fixedWidth: CGFloat {
		get { frameLayout.fixedWidth }
		set {
			frameLayout.fixedWidth = newValue
			setNeedsLayout()
		}
	}
	
	public var fixedHeight: CGFloat {
		get { frameLayout.fixedHeight }
		set {
			frameLayout.fixedHeight = newValue
			setNeedsLayout()
		}
	}
	
	/// Set minContentSize for every FrameLayout inside
	open var minItemSize: CGSize {
		get { frameLayout.minItemSize }
		set {
			frameLayout.minItemSize = newValue
			setNeedsLayout()
		}
	}
	
	/// Set maxContentSize for every FrameLayout inside
	open var maxItemSize: CGSize {
		get { frameLayout.maxItemSize }
		set {
			frameLayout.maxItemSize = newValue
			setNeedsLayout()
		}
	}
	
	/// Set fixedContentSize for every FrameLayout inside
	open var fixedItemSize: CGSize {
		get { frameLayout.fixedItemSize }
		set {
			frameLayout.fixedItemSize = newValue
			setNeedsLayout()
		}
	}
	
	public var extendSize: CGSize {
		get { frameLayout.extendSize }
		set {
			frameLayout.extendSize = newValue
			setNeedsLayout()
		}
	}
	
	public var extendWidth: CGFloat {
		get { frameLayout.extendWidth }
		set {
			frameLayout.extendWidth = newValue
			setNeedsLayout()
		}
	}
	
	public var extendHeight: CGFloat {
		get { frameLayout.extendHeight }
		set {
			frameLayout.extendHeight = newValue
			setNeedsLayout()
		}
	}
	
	public var contentFitSize: CGSize = CGSize(width: CGFloat.infinity, height: CGFloat.infinity) {
		didSet { setNeedsLayout() }
	}
	
	public var ignoreHiddenView: Bool {
		get { frameLayout.ignoreHiddenView }
		set {
			frameLayout.ignoreHiddenView = newValue
			setNeedsLayout()
		}
	}
	
	public var isIntrinsicSizeEnabled: Bool {
		get { frameLayout.isIntrinsicSizeEnabled }
		set {
			frameLayout.isIntrinsicSizeEnabled = newValue
			setNeedsLayout()
		}
	}
	
	public var isFlexible: Bool {
		get { frameLayout.isFlexible }
		set {
			frameLayout.isFlexible = newValue
			setNeedsLayout()
		}
	}
	
	public var isEnabled = true
	
	public var heightRatio: CGFloat {
		get { frameLayout.heightRatio }
		set {
			frameLayout.heightRatio = newValue
			setNeedsLayout()
		}
	}
	
	// Skeleton
	
	/// set color for skeleton mode
	public var skeletonColor: UIColor {
		get { frameLayout.skeletonColor }
		set {
			frameLayout.skeletonColor = newValue
			setNeedsLayout()
		}
	}
	public var skeletonMinSize: CGSize {
		get { frameLayout.skeletonMinSize }
		set {
			frameLayout.skeletonMinSize = newValue
			setNeedsLayout()
		}
	}
	public var skeletonMaxSize: CGSize {
		get { frameLayout.skeletonMaxSize }
		set {
			frameLayout.skeletonMaxSize = newValue
			setNeedsLayout()
		}
	}
	public var isSkeletonMode: Bool {
		get { frameLayout.isSkeletonMode }
		set {
			frameLayout.isSkeletonMode = newValue
			setNeedsLayout()
		}
	}
	
	public var frameLayouts: [FrameLayout] {
		get { frameLayout.frameLayouts }
		set { frameLayout.frameLayouts = newValue }
	}
	
	public var firstFrameLayout: FrameLayout? { frameLayout.firstFrameLayout }
	public var lastFrameLayout: FrameLayout? { frameLayout.lastFrameLayout }
	
	/// Block will be called before calling sizeThatFits
	@available(*, deprecated, renamed: "willSizeThatFitsBlock")
	public var preSizeThatFitsConfigurationBlock: ((ScrollStackView, CGSize) -> Void)? {
		get { willSizeThatFitsBlock }
		set { willSizeThatFitsBlock = newValue }
	}
	
	@available(*, deprecated, renamed: "willLayoutSubviewsBlock")
	public var preLayoutConfigurationBlock: ((ScrollStackView) -> Void)? {
		get { willLayoutSubviewsBlock }
		set { willLayoutSubviewsBlock = newValue }
	}
	
	/// Block will be called before calling sizeThatFits
	public var willSizeThatFitsBlock: ((ScrollStackView, CGSize) -> Void)?
	/// Block will be called before calling layoutSubviews
	public var willLayoutSubviewsBlock: ((ScrollStackView) -> Void)?
	/// Block will be called at the end of layoutSubviews function
	public var didLayoutSubviewsBlock: ((ScrollStackView) -> Void)?
	
	public let scrollView = UIScrollView()
	public let frameLayout = StackFrameLayout(axis: .vertical, distribution: .top)
	
	// MARK: -
	
	convenience public init(axis: NKLayoutAxis = .vertical, distribution: NKLayoutDistribution = .top, views: [UIView]? = nil) {
		self.init()
		
		self.axis = axis
		self.distribution = distribution
		
		defer {
			if let views, !views.isEmpty {
				self.views = views
			}
		}
	}
	
	@discardableResult
	public convenience init(_ block: (ScrollStackView) throws -> Void) rethrows {
		self.init()
		try block(self)
	}
	
	public required init() {
		super.init(frame: .zero)
		
		scrollView.bounces = true
		scrollView.alwaysBounceHorizontal = false
		scrollView.alwaysBounceVertical = false
		scrollView.isDirectionalLockEnabled = true
		scrollView.showsVerticalScrollIndicator = false
		scrollView.showsHorizontalScrollIndicator = false
		scrollView.clipsToBounds = false
		scrollView.delaysContentTouches = false
		
		#if os(iOS)
		if #available(iOS 11.0, *) { scrollView.contentInsetAdjustmentBehavior = .never }
		if #available(iOS 13.0, *) { scrollView.automaticallyAdjustsScrollIndicatorInsets = false }
		#endif
		
		frameLayout.spacing = 0.0
		frameLayout.isIntrinsicSizeEnabled = true
		frameLayout.shouldCacheSize = false
		scrollView.addSubview(frameLayout)
		addSubview(scrollView)
	}
	
	required public init?(coder aDecoder: NSCoder) {
		super.init(coder: aDecoder)
	}
	
	override open func sizeThatFits(_ size: CGSize) -> CGSize {
		if !isEnabled { return .zero }
		willSizeThatFitsBlock?(self, size)
		return frameLayout.sizeThatFits(size)
	}
	
	override open func layoutSubviews() {
		if !isEnabled { return }
		
		willLayoutSubviewsBlock?(self)
		super.layoutSubviews()
		
		let viewSize = bounds.size
		let sizeToFit = !isDirectionalLockEnabled ? contentFitSize : (axis == .horizontal ? CGSize(width: contentFitSize.width, height: viewSize.height) : CGSize(width: viewSize.width, height: contentFitSize.height))
		let contentSize = frameLayout.sizeThatFits(sizeToFit, intrinsic: true)
		scrollView.contentSize = contentSize
		scrollView.frame = bounds
		
		var contentFrame = bounds
		if axis == .horizontal {
			contentFrame.size.width = max(viewSize.width, contentSize.width)
			if isDirectionalLockEnabled {
				scrollView.contentSize.height = min(viewSize.height, contentSize.height)
			}
			else {
				contentFrame.size.height = max(viewSize.height, contentSize.height)
			}
		}
		else {
			contentFrame.size.height = max(viewSize.height, contentSize.height)
			if isDirectionalLockEnabled {
				scrollView.contentSize.width = min(viewSize.width, contentSize.width)
			}
			else {
				contentFrame.size.width = max(viewSize.width, contentSize.width)
			}
		}
		
		frameLayout.frame = contentFrame
		didLayoutSubviewsBlock?(self)
	}
	
	// MARK: -
	
	public func view(at index: Int) -> UIView? { frameLayout.frameLayout(at: index)?.targetView }
	public func frameLayout(at index: Int) -> FrameLayout? { frameLayout.frameLayout(at: index) }
	public func frameLayout(with view: UIView) -> FrameLayout? { frameLayout.frameLayout(with: view) }
	public func enumerate(_ block: (FrameLayout, Int, inout Bool) -> Void) { frameLayout.enumerate(block) }

	@discardableResult
	public func flexible(ratio: CGFloat = -1) -> Self {
		frameLayout.flexible(ratio: ratio)
		return self
	}
	
	@discardableResult
	public func invert() -> Self {
		frameLayout.invert()
		return self
	}
	
	@discardableResult
	open func add(_ view: UIView?) -> FrameLayout {
		let layout = frameLayout.add(view)
		if let view { scrollView.addSubview(view) }
		setNeedsLayout()
		return layout
	}
	
	@discardableResult
	open func add(_ views: [UIView]) -> [FrameLayout] {
		return views.map { add($0) }
	}
	
	@discardableResult
	open func insert(_ view: UIView?, at index: Int, invert: Bool = false) -> FrameLayout {
		let targetIndex = invert ? max(frameLayouts.count - index, 0) : index
		let layout = frameLayout.insert(view, at: targetIndex)
		if let view { scrollView.insertSubview(view, at: targetIndex) }
		setNeedsLayout()
		return layout
	}
	
	@discardableResult
	open func addSpace(_ size: CGFloat = 0) -> FrameLayout {
		let layout = add(UIView())
		layout.minSize = CGSize(width: axis == .horizontal ? size : 0, height: axis == .vertical ? size : 0)
		return layout
	}
	
	@discardableResult
	open func replace(view: UIView, at index: Int) -> Self {
		self.view(at: index)?.removeFromSuperview()
		scrollView.addSubview(view)
		frameLayout.frameLayout(at: index)?.targetView = view
		setNeedsLayout()
		return self
	}

	@discardableResult
	open func removeView(at index: Int) -> Self {
		frameLayout.removeFrameLayout(at: index, autoRemoveTargetView: true)
		setNeedsLayout()
		return self
	}
	
	@discardableResult
	open func removeAll() -> Self {
		frameLayout.removeAll(autoRemoveTargetView: true)
		setNeedsLayout()
		return self
	}
	
	open func relayoutSubviews(animateDuration: TimeInterval = 0.35, options: UIView.AnimationOptions = .curveEaseInOut, completion: ((Bool) -> Void)? = nil) {
		setNeedsLayout()
		
		UIView.animate(withDuration: animateDuration, delay: 0.0, options: options, animations: {
			self.layoutIfNeeded()
		}, completion: completion)
	}
	
	@discardableResult
	open func padding(top: CGFloat = 0, left: CGFloat = 0, bottom: CGFloat = 0, right: CGFloat = 0) -> Self {
		edgeInsets = UIEdgeInsets(top: top, left: left, bottom: bottom, right: right)
		return self
	}
	
	@discardableResult
	open func addPadding(top: CGFloat = 0, left: CGFloat = 0, bottom: CGFloat = 0, right: CGFloat = 0) -> Self {
		edgeInsets = UIEdgeInsets(top: edgeInsets.top + top, left: edgeInsets.left + left, bottom: edgeInsets.bottom + bottom, right: edgeInsets.right + right)
		return self
	}
	
	override open func setNeedsLayout() {
		super.setNeedsLayout()
		frameLayout.setNeedsLayout()
	}
	
	open override func layoutIfNeeded() {
		super.layoutIfNeeded()
		frameLayout.layoutIfNeeded()
	}
	
	/**
	 This will set `isUserInteractionEnabled` as well as all sub-frameLayouts to the same value.
	 - parameter enabled: The name says it all
	 */
	@discardableResult
	public func setUserInteraction(enabled: Bool) -> Self {
		isUserInteractionEnabled = enabled
		frameLayouts.forEach { $0.isUserInteractionEnabled = enabled }
		return self
	}
	
	// MARK: -
	
	fileprivate func updateLayout() {
		if _views.isEmpty {
			frameLayout.removeAll(autoRemoveTargetView: true)
		}
		else {
			let total = _views.count
			
			if frameLayout.frameLayouts.count > total {
				frameLayout.enumerate { layout, index, _ in
					if Int(index) >= Int(total) {
						layout.targetView?.removeFromSuperview()
					}
				}
			}
			
			frameLayout.numberOfFrameLayouts = total
			
			frameLayout.enumerate { layout, idx, _ in
				let view = views[idx]
				scrollView.addSubview(view)
				layout.targetView = view
			}
		}
		
		setNeedsLayout()
	}
	
}



================================================
FILE: FrameLayoutKit/Classes/StackFrameLayout.swift
================================================
//
//  StackFrameLayout.swift
//  FrameLayoutKit
//
//  Created by Nam Kennic on 7/19/18.
//

import UIKit

open class StackFrameLayout: FrameLayout {
	public var distribution: NKLayoutDistribution = .top
	public var axis: NKLayoutAxis = .vertical
	
	public var spacing: CGFloat = 0 {
		didSet {
			if spacing != oldValue {
				setNeedsLayout()
			}
		}
	}
	
	public var isOverlapped: Bool = false {
		didSet { setNeedsLayout() }
	}
	
	public var isJustified: Bool = false {
		didSet { setNeedsLayout() }
	}
	
	public var justifyThreshold: CGFloat = 0.0 {
		didSet { setNeedsLayout() }
	}
	
	override open var ignoreHiddenView: Bool {
		didSet {
			super.ignoreHiddenView = ignoreHiddenView
			frameLayouts.forEach { $0.ignoreHiddenView = ignoreHiddenView }
		}
	}
	
	override open var shouldCacheSize: Bool {
		didSet {
			super.shouldCacheSize = shouldCacheSize
			frameLayouts.forEach { $0.shouldCacheSize = shouldCacheSize }
		}
	}
	
	override open var debug: Bool {
		didSet {
			super.debug = debug
			frameLayouts.forEach { $0.debug = debug }
		}
	}
	
	override open var debugColor: UIColor?{
		didSet {
			super.debugColor = debugColor
			frameLayouts.forEach { $0.debugColor = debugColor }
		}
	}
	
	/// Set minContentSize for every FrameLayout inside
	open var minItemSize: CGSize = .zero {
		didSet { frameLayouts.forEach { $0.minContentSize = minItemSize } }
	}
	
	/// Set maxContentSize for every FrameLayout inside
	open var maxItemSize: CGSize = .zero {
		didSet { frameLayouts.forEach { $0.maxContentSize = maxItemSize } }
	}
	
	/// Set fixedContentSize for every FrameLayout inside
	open var fixedItemSize: CGSize = .zero {
		didSet { frameLayouts.forEach { $0.fixedContentSize = fixedItemSize } }
	}
	
	/// Allow content view to expand its height to fill its frameLayout when the layout is higher than the view itself
	override open var allowContentVerticalGrowing: Bool {
		didSet { frameLayouts.forEach { $0.allowContentVerticalGrowing = allowContentVerticalGrowing } }
	}
	
	/// Allow content view to shrink its height to fit its frameLayout when the layout is shorter than the view itself
	override open var allowContentVerticalShrinking: Bool {
		didSet { frameLayouts.forEach { $0.allowContentVerticalShrinking = allowContentVerticalShrinking } }
	}
	
	/// Allow content view to expand its width to fill its frameLayout when the layout is wider than the view itself
	override open var allowContentHorizontalGrowing: Bool {
		didSet { frameLayouts.forEach { $0.allowContentHorizontalGrowing = allowContentHorizontalGrowing } }
	}
	
	/// Allow content view to shrink its width to fit its frameLayout when the layout is narrower than the view itself
	override open var allowContentHorizontalShrinking: Bool {
		didSet { frameLayouts.forEach { $0.allowContentHorizontalShrinking = allowContentHorizontalShrinking } }
	}
	
	/*
	public override var isUserInteractionEnabled: Bool {
		didSet { frameLayouts.forEach { $0.isUserInteractionEnabled = isUserInteractionEnabled } }
	}
	*/
	
	override open var frame: CGRect {
		didSet { setNeedsLayout() }
	}
	
	override open var bounds: CGRect {
		didSet { setNeedsLayout() }
	}
	
	override open var clipsToBounds: Bool {
		didSet {
			super.clipsToBounds = clipsToBounds
			frameLayouts.forEach { $0.clipsToBounds = clipsToBounds }
		}
	}
	
	public var firstFrameLayout: FrameLayout? { frameLayouts.first }
	public var lastFrameLayout: FrameLayout? { frameLayouts.last }
	
	public internal(set) var frameLayouts: [FrameLayout] = []
	
	public var numberOfFrameLayouts: Int {
		get { frameLayouts.count }
		set {
			let count = frameLayouts.count
			
			if newValue == 0 {
				removeAll()
				return
			}
			
			if newValue < count {
				while frameLayouts.count > newValue {
					removeFrameLayout(at: frameLayouts.count - 1)
				}
			}
			else if newValue > count {
				for _ in 0..<(newValue - count) {
					add()
				}
			}
		}
	}
	
	// Skeleton
	
	/// set color for skeleton mode
	override public var skeletonColor: UIColor {
		didSet {
			frameLayouts.forEach { $0.skeletonColor = skeletonColor }
		}
	}
	override public var skeletonMinSize: CGSize {
		didSet {
			frameLayouts.forEach { $0.skeletonMinSize = skeletonMinSize }
		}
	}
	override public var skeletonMaxSize: CGSize {
		didSet {
			frameLayouts.forEach { $0.skeletonMaxSize = skeletonMaxSize }
		}
	}
	override public var isSkeletonMode: Bool {
		didSet {
			frameLayouts.forEach { $0.isSkeletonMode = isSkeletonMode }
			setNeedsLayout()
		}
	}
	
	// MARK: -
	
	convenience public init(axis: NKLayoutAxis, distribution: NKLayoutDistribution = .top, views: [UIView]? = nil) {
		self.init()
		
		self.axis = axis
		self.distribution = distribution
		
		if let views { add(views) }
	}
	
	public required init() {
		super.init()
		isIntrinsicSizeEnabled = true
	}
	
	public required init?(coder aDecoder: NSCoder) {
		super.init(coder: aDecoder)
	}
	
	// MARK: -
	
	@discardableResult
	open func add(_ views: [UIView]) -> [FrameLayout] {
		return views.map { add($0) }
	}
	
	@discardableResult
	open func add(_ view: UIView? = nil) -> FrameLayout {
		if let frameLayout = view as? FrameLayout, frameLayout.superview == nil {
			applyCommonAttributes(to: frameLayout)
			frameLayouts.append(frameLayout)
			addSubview(frameLayout)
			return frameLayout
		}
		else {
			if let view, view.superview == nil {
				#if DEBUG
				if FrameLayout.showDebugWarnings, !isUserInteractionEnabled, view is UIControl {
					print("⚠️ [FrameLayoutKit] \(view) was automatically added to StackFrameLayout \(self) which was disabled user interation. This could make your control unable to interact. You can either set isUserInteractionEnabled = true for this FrameLayout or addSubview(your control) before adding to frameLayout.")
				}
				#endif
				addSubview(view)
			}
			
			let frameLayout = FrameLayout(targetView: view)
			frameLayout.fixedContentSize = fixedItemSize
			frameLayout.minContentSize = minItemSize
			frameLayout.maxContentSize = maxItemSize
			applyCommonAttributes(to: frameLayout)
			frameLayouts.append(frameLayout)
			addSubview(frameLayout)
			return frameLayout
		}
	}
	
	@discardableResult
	open func insert(_ view: UIView?, at index: Int, invert: Bool = false) -> FrameLayout {
		let targetIndex = invert ? max(frameLayouts.count - index, 0) : index
		
		if let frameLayout = view as? FrameLayout, frameLayout.superview == nil {
			applyCommonAttributes(to: frameLayout)
			frameLayouts.insert(frameLayout, at: targetIndex)
			addSubview(frameLayout)
			return frameLayout
		}
		else {
			if let view, view.superview == nil {
				#if DEBUG
				if FrameLayout.showDebugWarnings, !isUserInteractionEnabled, view is UIControl {
					print("⚠️ [FrameLayoutKit] \(view) was automatically added to StackFrameLayout \(self) which was disabled user interation. This could make your control unable to interact. You can either set isUserInteractionEnabled = true for this FrameLayout or addSubview(your control) before adding to frameLayout.")
				}
				#endif
				addSubview(view)
			}
			
			let frameLayout = FrameLayout(targetView: view)
			frameLayout.fixedContentSize = fixedItemSize
			frameLayout.minContentSize = minItemSize
			frameLayout.maxContentSize = maxItemSize
			applyCommonAttributes(to: frameLayout)
			frameLayouts.insert(frameLayout, at: targetIndex)
			addSubview(frameLayout)
			return frameLayout
		}
	}
	
	func applyCommonAttributes(to frameLayout: FrameLayout) {
		frameLayout.parent = self
		frameLayout.debug = debug
		frameLayout.debugColor = debugColor
		frameLayout.ignoreHiddenView = ignoreHiddenView
		frameLayout.isSkeletonMode = isSkeletonMode || frameLayout.isSkeletonMode
		frameLayout.skeletonColor = skeletonColor
	}
	
	@discardableResult
	open func addSpace(_ size: CGFloat = 0) -> FrameLayout {
		let frameLayout = add()
		frameLayout.minSize = CGSize(width: size, height: size)
		return frameLayout
	}
	
	@discardableResult
	open func removeFrameLayout(at index: Int, autoRemoveTargetView: Bool = false) -> Self {
		guard index >= 0 && index < frameLayouts.count else { return self }
		
		let frameLayout = frameLayouts[index]
		if frameLayout.superview == self { frameLayout.removeFromSuperview() }
		if autoRemoveTargetView { frameLayout.targetView?.removeFromSuperview() }
		
		frameLayout.targetView = nil
		frameLayout.parent = nil
		frameLayouts.remove(at: index)
		return self
	}
	
	@discardableResult
	open func removeAll(autoRemoveTargetView: Bool = false) -> Self {
		for layout in frameLayouts {
			if autoRemoveTargetView { layout.targetView?.removeFromSuperview() }
			layout.targetView = nil
			layout.parent = nil
			if layout.superview == self { layout.removeFromSuperview() }
		}
		
		frameLayouts.removeAll()
		return self
	}
	
	@discardableResult
	open func replace(_ frameLayout: FrameLayout?, at index: Int, autoRemoveOldTargetView: Bool = false) -> Self {
		guard let frameLayout = frameLayout else {
			removeFrameLayout(at: index, autoRemoveTargetView: autoRemoveOldTargetView)
			return self
		}
		
		let count = frameLayouts.count
		var currentFrameLayout: FrameLayout? = nil
		
		if index < count {
			currentFrameLayout = frameLayouts[index]
		}
		
		if let currentFrameLayout, currentFrameLayout != frameLayout {
			if currentFrameLayout.superview == self { currentFrameLayout.removeFromSuperview() }
			currentFrameLayout.parent = nil
			frameLayouts.insert(frameLayout, at: index)
			addSubview(frameLayout)
		}
		else if index == count {
			insert(nil, at: index)
		}
		
		return self
	}
	
	@discardableResult
	public func invert() -> Self {
		frameLayouts = frameLayouts.reversed()
		setNeedsLayout()
		return self
	}
	
	/**
	 This will set `isUserInteractionEnabled` as well as all sub-frameLayouts to the same value.
	 - parameter enabled: The name says it all
	 */
	@discardableResult
	public func setUserInteraction(enabled: Bool) -> Self {
		isUserInteractionEnabled = enabled
		frameLayouts.forEach { $0.isUserInteractionEnabled = enabled }
		return self
	}
	
	// MARK: -
	
	public func frameLayout(at index: Int) -> FrameLayout? {
		guard index >= 0 && index < frameLayouts.count else { return nil }
		return frameLayouts[index]
	}
	
	public func frameLayout(with view: UIView) -> FrameLayout? {
		if targetView == view { return self }
		
		var result: FrameLayout? = nil
		enumerate { layout, _, stop in
			if layout.targetView == view {
				result = layout
			}
			else if let subStack = layout as? StackFrameLayout {
				result = subStack.frameLayout(with: view)
			}
			
			if result != nil { stop = true }
		}
		
		return result;
	}
	
	public func enumerate(_ block: (FrameLayout, Int, inout Bool) -> Void) {
		var stop = false
		var index = 0
		
		for layout in frameLayouts {
			block(layout, index, &stop)
			if stop { break }
			
			index += 1
		}
	}
	
	@discardableResult
	public func justified(threshold: CGFloat = 0) -> Self {
		justifyThreshold = threshold
		isJustified = true
		return self
	}
	
	// MARK: -
	
	override open func setNeedsLayout() {
		super.setNeedsLayout()
		frameLayouts.forEach { $0.setNeedsLayout() }
	}
	
	fileprivate func visibleFrames() -> [FrameLayout] { frameLayouts.filter { !$0.isEmpty } }
	fileprivate func numberOfVisibleFrames() -> Int { visibleFrames().count }
	
	// MARK: -
	
	open override func sizeThatFits(_ size: CGSize, ignoreHiddenView: Bool) -> CGSize {
		if !isEnabled { return .zero }
		willSizeThatFitsBlock?(self, size)
		
		var result: CGSize = size
		let verticalEdgeValues = edgeInsets.left + edgeInsets.right
		let horizontalEdgeValues = edgeInsets.top + edgeInsets.bottom
		
		if minSize == maxSize && minSize.width > 0 && minSize.height > 0 {
			result = minSize
		}
		else if heightRatio > 0 && !isIntrinsicSizeEnabled {
			result.height = result.width * heightRatio
		}
		else {
			let contentSize = CGSize(width: max(size.width - verticalEdgeValues, 0), height: max(size.height - horizontalEdgeValues, 0))
			
			if isOverlapped {
				result = .zero
				
				for frameLayout in frameLayouts {
					if frameLayout.isEmpty { continue }
					
					let frameSize = frameLayout.sizeThatFits(contentSize)
					result.width = isIntrinsicSizeEnabled ? max(result.width, frameSize.width) : size.width
					result.height = max(result.height, frameSize.height)
				}
				
				if heightRatio > 0 { result.height = result.width * heightRatio }
				if result.width > 0 { result.width += verticalEdgeValues }
				if result.height > 0 { result.height += horizontalEdgeValues }
				
				result.width = min(result.width, size.width)
				result.height = min(result.height, size.height)
				
				return result
			}
			
			var gapSpace: CGFloat = 0
			var totalSpace: CGFloat = 0
			var frameContentSize: CGSize = .zero
			
			let isInvertedAlignment = distribution == .bottom || distribution == .right
			let activeFrameLayouts: [FrameLayout] = (isInvertedAlignment ? frameLayouts.reversed() : frameLayouts)
			let lastFrameLayout: FrameLayout? = activeFrameLayouts.last(where: { !$0.isEmpty })
			
			if axis == .horizontal {
				var maxHeight: CGFloat = 0
				
				switch distribution {
					case .left, .right, .top, .bottom, .center:
						var flexibleFrames = [FrameLayout]()
						for frameLayout in activeFrameLayouts {
							if frameLayout.isEmpty { continue }
							
							if frameLayout.isFlexible {
								flexibleFrames.append(frameLayout)
								continue
							}
							
							frameContentSize = CGSize(width: contentSize.width - totalSpace, height: contentSize.height)
							frameContentSize = frameLayout.sizeThatFits(frameContentSize)
							
							gapSpace = frameContentSize.width > 0 && frameLayout != lastFrameLayout ? spacing : 0
							totalSpace += frameContentSize.width + gapSpace
							maxHeight = max(maxHeight, frameContentSize.height)
						}
						
						let flexibleFrameCount = flexibleFrames.count
						if flexibleFrameCount > 0 {
							let remainingSpace = CGFloat(flexibleFrameCount - 1) * spacing
							let contentWidth = contentSize.width - totalSpace - remainingSpace
							let ratio = flexibleFrames.map { $0.flexibleRatio }.autoFill(total: flexibleFrameCount)
							
							var ratioIndex = 0
							flexibleFrames.forEach {
								let ratioValue = ratio[ratioIndex]
								let cellWidth = contentWidth * ratioValue
								frameContentSize = CGSize(width: cellWidth, height: contentSize.height)
								frameContentSize = $0.sizeThatFits(frameContentSize)
								
								gapSpace = frameContentSize.width > 0 && $0 != lastFrameLayout ? spacing : 0
								totalSpace += frameContentSize.width + gapSpace
								maxHeight = max(maxHeight, frameContentSize.height)
								ratioIndex += 1
							}
						}
						
						break
					
					case .equal:
						let visibleFrameLayouts = visibleFrames()
						let visibleFrameCount = visibleFrameLayouts.count
						let spaces = CGFloat(visibleFrameCount - 1) * spacing
						let contentWidth = contentSize.width - spaces
						let cellWidth = contentWidth / CGFloat(visibleFrameCount)
						
						visibleFrameLayouts.forEach {
							frameContentSize = CGSize(width: cellWidth, height: contentSize.height).limitTo(minSize: $0.minSize, maxSize: $0.maxSize)
							frameContentSize = $0.sizeThatFits(frameContentSize)
							
							gapSpace = frameContentSize.width > 0 && $0 != lastFrameLayout ? spacing : 0
							totalSpace += frameContentSize.width + gapSpace
							maxHeight = max(maxHeight, frameContentSize.height)
						}
						
						break
					
					case .split(let ratio):
						let visibleFrameLayouts = visibleFrames()
						let visibleFrameCount = visibleFrameLayouts.count
						let spaces = CGFloat(visibleFrameCount - 1) * spacing
						let contentWidth = contentSize.width - spaces
						let finalRatio = ratio.autoFill(total: visibleFrameCount)
						
						var ratioIndex = 0
						visibleFrameLayouts.forEach {
							let ratioValue = finalRatio[ratioIndex]
							let cellWidth = contentWidth * ratioValue
							frameContentSize = CGSize(width: cellWidth, height: contentSize.height).limitTo(minSize: $0.minSize, maxSize: $0.maxSize)
							frameContentSize = $0.sizeThatFits(frameContentSize)
							
							gapSpace = frameContentSize.width > 0 && $0 != lastFrameLayout ? spacing : 0
							totalSpace += frameContentSize.width + gapSpace
							maxHeight = max(maxHeight, frameContentSize.height)
							ratioIndex += 1
						}
						break
				}
				
				if isIntrinsicSizeEnabled {
					result.width = totalSpace
				}
				
				result.height = min(maxHeight, size.height)
			}
			else { // if axis == .vertical {
				var maxWidth: CGFloat = 0
				var flexibleFrames = [FrameLayout]()
				for frameLayout in frameLayouts {
					if frameLayout.isEmpty { continue }
					if frameLayout.isFlexible {
						flexibleFrames.append(frameLayout)
						continue
					}
					
					frameContentSize = CGSize(width: contentSize.width, height: contentSize.height - totalSpace)
					frameContentSize = frameLayout.sizeThatFits(frameContentSize)
					
					gapSpace = frameContentSize.height > 0 && frameLayout != lastFrameLayout ? spacing : 0
					totalSpace += frameContentSize.height + gapSpace
					maxWidth = max(maxWidth, frameContentSize.width)
				}
				
				let flexibleFrameCount = flexibleFrames.count
				if flexibleFrameCount > 0 {
					let remainingSpace = CGFloat(flexibleFrameCount - 1) * spacing
					let contentHeight = contentSize.height - totalSpace - remainingSpace
					let ratio = flexibleFrames.map { $0.flexibleRatio }.autoFill(total: flexibleFrameCount)
					
					var ratioIndex = 0
					flexibleFrames.forEach {
						let ratioValue = ratio[ratioIndex]
						let cellHeight = contentHeight * ratioValue
						frameContentSize = CGSize(width: contentSize.width, height: cellHeight)
						frameContentSize = $0.sizeThatFits(frameContentSize)
						
						gapSpace = frameContentSize.height > 0 && $0 != lastFrameLayout ? spacing : 0
						totalSpace += frameContentSize.height + gapSpace
						maxWidth = max(maxWidth, frameContentSize.width)
						ratioIndex += 1
					}
				}
				
				if isIntrinsicSizeEnabled { result.width = maxWidth }
				result.height = min(totalSpace, size.height)
			}
			
			result.limitedTo(minSize: minSize, maxSize: maxSize)
		}
		
		if result.width > 0 { result.width += verticalEdgeValues }
		if result.height > 0 { result.height += horizontalEdgeValues }
		
		result.width = min(result.width, size.width)
		result.height = min(result.height, size.height)
		
		return result
	}
	
	override open func layoutSubviews() {
		super.layoutSubviews()
		if !isEnabled { return }
		
		defer {
			didLayoutSubviewsBlock?(self)
		}
		
		if bounds.size == .zero { return }
		
		#if swift(>=4.2)
		let containerFrame = bounds.inset(by: edgeInsets)
		#else
		let containerFrame = UIEdgeInsetsInsetRect(bounds, edgeInsets)
		#endif
		
		var gapSpace: CGFloat = 0
		var usedSpace: CGFloat = 0
		var frameContentSize: CGSize = .zero
		var targetFrame = containerFrame
		
		let isInvertedAlignment = distribution == .bottom || distribution == .right
		let invertedLayoutArray: [FrameLayout] = frameLayouts.reversed()
		var lastFrameLayout: FrameLayout? = (isInvertedAlignment ? frameLayouts : invertedLayoutArray).first(where: { !$0.isEmpty })
		
		if axis == .horizontal {
			switch distribution {
				case .top, .left:
					if isOverlapped {
						for frameLayout in frameLayouts {
							frameContentSize = frameLayout.isFlexible ? CGSize(width: containerFrame.width * (frameLayout.flexibleRatio < 0.0 ? 1.0 : frameLayout.flexibleRatio), height: containerFrame.height) : frameLayout.sizeThatFits(containerFrame.size, ignoreHiddenView: false)
							targetFrame.origin.x = containerFrame.minX
							targetFrame.size.width = frameContentSize.width
							targetFrame.size.height = containerFrame.height
							frameLayout.frame = targetFrame
						}
						break
					}
					
					var flexibleFrames = [FrameLayout]()
					
					for frameLayout in frameLayouts {
						let isEmpty = frameLayout.isEmpty
						
						if frameLayout.isFlexible && !isEmpty {
							flexibleFrames.append(frameLayout)
							lastFrameLayout = frameLayout
							continue
						}
						
						frameContentSize = CGSize(width: containerFrame.width - usedSpace, height: containerFrame.height)
						let fitSize = frameLayout.sizeThatFits(frameContentSize, ignoreHiddenView: false)
						
						if frameLayout == lastFrameLayout && !frameLayout.isIntrinsicSizeEnabled {
							frameContentSize.height = fitSize.height
						}
						else {
							frameContentSize = fitSize
						}
						
						targetFrame.origin.x = containerFrame.minX + usedSpace
						targetFrame.size.width = frameContentSize.width
						frameLayout.frame = targetFrame
						
						if isEmpty { continue }
						
						gapSpace = frameContentSize.width > 0 ? spacing : 0
						usedSpace += frameContentSize.width + gapSpace
					}
					
					let flexibleFrameCount = flexibleFrames.count
					if flexibleFrameCount > 0 {
						let remainingSpace = CGFloat(flexibleFrameCount - 1) * spacing
						let contentWidth = containerFrame.width - usedSpace - remainingSpace
						let ratio = flexibleFrames.map { $0.flexibleRatio }.autoFill(total: flexibleFrameCount)
						
						gapSpace = 0
						var ratioIndex = 0
						var offset: CGFloat = edgeInsets.left
						for frameLayout in frameLayouts {
							var rect = frameLayout.frame
							let isEmpty = frameLayout.isEmpty
							
							if frameLayout.isFlexible && !isEmpty {
								let ratioValue = ratio[ratioIndex]
								let cellWidth = contentWidth * ratioValue
								
								rect = targetFrame
								rect.size = CGSize(width: cellWidth, height: containerFrame.height).limitTo(minSize: frameLayout.minSize, maxSize: frameLayout.maxSize)
								ratioIndex += 1
							}
							
							if rect.minX != offset || frameLayout.frame.size != rect.size {
								rect.origin.x = offset
								frameLayout.frame = rect
							}
							
							if isEmpty { continue }
							
							gapSpace = rect.width > 0 ? spacing : 0
							offset += rect.width + gapSpace
						}
					}
					else if isJustified {
						let remainingWidth = containerFrame.width - usedSpace
						let numberOfSpaces = numberOfVisibleFrames() - 1
						
						if remainingWidth > justifyThreshold, numberOfSpaces > 0 {
							let spaces = CGFloat(numberOfSpaces)
							let extraValuePerSpace = (remainingWidth / spaces) + (spacing / spaces)
							let firstFrame = frameLayouts.first(where: { !$0.isEmpty })
							
							var index = 1
							for frameLayout in frameLayouts {
								if frameLayout == firstFrame { continue }
								var rect = frameLayout.frame
								rect.origin.x += extraValuePerSpace * CGFloat(index)
								frameLayout.frame = rect
								
								if !frameLayout.isEmpty { index += 1 }
							}
						}
					}
					
					break
				
				case .bottom, .right:
					if isOverlapped {
						for frameLayout in frameLayouts {
							frameContentSize = frameLayout.isFlexible ? containerFrame.size : frameLayout.sizeThatFits(containerFrame.size, ignoreHiddenView: false)
							targetFrame.size.width = frameContentSize.width
							targetFrame.size.height = containerFrame.height
							targetFrame.origin.x = containerFrame.width - targetFrame.width
							frameLayout.frame = targetFrame
						}
						break
					}
					
					var flexibleFrames = [FrameLayout]()
					
					for frameLayout in invertedLayoutArray {
						let isEmpty = frameLayout.isEmpty
						
						if frameLayout.isFlexible && !isEmpty {
							flexibleFrames.append(frameLayout)
							lastFrameLayout = frameLayout
							continue
						}
						
						if frameLayout == lastFrameLayout && !frameLayout.isIntrinsicSizeEnabled {
							targetFrame.origin.x = edgeInsets.left
							targetFrame.size.width = containerFrame.width - usedSpace
						}
						else {
							frameContentSize = CGSize(width: containerFrame.width - usedSpace, height: containerFrame.height)
							frameContentSize = frameLayout.sizeThatFits(frameContentSize, ignoreHiddenView: false)
							
							targetFrame.origin.x = max(bounds.width - frameContentSize.width - edgeInsets.right - usedSpace, 0)
							targetFrame.size.width = frameContentSize.width
						}
						
						frameLayout.frame = targetFrame
						
						if isEmpty { continue }
						
						gapSpace = frameContentSize.width > 0 ? spacing : 0
						usedSpace += frameContentSize.width + gapSpace
					}
					
					let flexibleFrameCount = flexibleFrames.count
					if flexibleFrameCount > 0 {
						let remainingSpace = CGFloat(flexibleFrameCount - 1) * spacing
						let contentWidth = containerFrame.width - usedSpace - remainingSpace
						let ratio = flexibleFrames.map { $0.flexibleRatio }.autoFill(total: flexibleFrameCount)
						
						gapSpace = 0
						var ratioIndex = 0
						var offset: CGFloat = containerFrame.width + edgeInsets.left
						for frameLayout in invertedLayoutArray {
							var rect = frameLayout.frame
							let isEmpty = frameLayout.isEmpty
							
							if frameLayout.isFlexible && !isEmpty {
								let ratioValue = ratio[ratioIndex]
								let cellWidth = contentWidth * ratioValue
								
								rect = targetFrame
								rect.size = CGSize(width: cellWidth, height: containerFrame.height).limitTo(minSize: frameLayout.minSize, maxSize: frameLayout.maxSize)
								ratioIndex += 1
							}
							
							offset -= rect.width + gapSpace
							
							if rect.minX != offset || frameLayout.frame.size != rect.size {
								rect.origin.x = offset
								frameLayout.frame = rect
							}
							
							if isEmpty { continue }
							
							gapSpace = rect.width > 0 ? spacing : 0
						}
					}
					else if isJustified {
						let remainingWidth = containerFrame.width - usedSpace
						let numberOfSpaces = numberOfVisibleFrames() - 1
						
						if remainingWidth > justifyThreshold, numberOfSpaces > 0 {
							let spaces = CGFloat(numberOfSpaces)
							let extraValuePerSpace = (remainingWidth / spaces) + (spacing / spaces)
							let lastFrame = invertedLayoutArray.first(where: { !$0.isEmpty })
							
							var index = 1
							for frameLayout in invertedLayoutArray {
								if frameLayout == lastFrame { continue }
								var rect = frameLayout.frame
								rect.origin.x -= extraValuePerSpace * CGFloat(index)
								frameLayout.frame = rect
								if !frameLayout.isEmpty { index += 1 }
							}
						}
					}
					break
				
				case .equal:
					let visibleFrameLayouts = visibleFrames()
					let visibleFrameCount = visibleFrameLayouts.count
					let spaces = CGFloat(visibleFrameCount - 1) * spacing
					let cellWidth = (containerFrame.width - spaces) / CGFloat(Float(visibleFrameCount))
					
					if isOverlapped {
						for frameLayout in frameLayouts {
							frameContentSize = frameLayout.isFlexible ? containerFrame.size : CGSize(width: cellWidth, height: containerFrame.height).limitTo(minSize: frameLayout.minSize, maxSize: frameLayout.maxSize)
							
							targetFrame.origin.x = containerFrame.minX
							targetFrame.size.width = frameContentSize.width
							targetFrame.size.height = containerFrame.height
							frameLayout.frame = targetFrame
						}
						break
					}
					
					for frameLayout in frameLayouts {
						frameContentSize = CGSize(width: cellWidth, height: containerFrame.height).limitTo(minSize: frameLayout.minSize, maxSize: frameLayout.maxSize)
						targetFrame.origin.x = containerFrame.minX + usedSpace
						targetFrame.size.width = frameContentSize.width
						frameLayout.frame = targetFrame
						
						if frameLayout.isEmpty { continue }
						
						gapSpace = frameContentSize.width > 0 ? spacing : 0
						usedSpace += frameContentSize.width + gapSpace
					}
					break
				
				case .split(let ratio):
					let visibleFrameCount = numberOfVisibleFrames()
					let spaces: CGFloat = CGFloat(visibleFrameCount - 1) * spacing
					let contentWidth = containerFrame.width - spaces
					let finalRatio = ratio.autoFill(total: visibleFrameCount)
					
					var ratioIndex = 0
					
					if isOverlapped {
						for frameLayout in frameLayouts {
							let ratioValue = finalRatio[ratioIndex]
							frameContentSize = frameLayout.isFlexible ? containerFrame.size : CGSize(width: contentWidth * ratioValue, height: containerFrame.height).limitTo(minSize: frameLayout.minSize, maxSize: frameLayout.maxSize)
							
							targetFrame.origin.x = containerFrame.minX
							targetFrame.size.width = frameContentSize.width
							targetFrame.size.height = containerFrame.height
							frameLayout.frame = targetFrame
							ratioIndex += 1
						}
						break
					}
					
					for frameLayout in frameLayouts {
						let ratioValue = finalRatio[ratioIndex]
						let cellWidth = contentWidth * ratioValue
						frameContentSize = CGSize(width: cellWidth, height: containerFrame.height).limitTo(minSize: frameLayout.minSize, maxSize: frameLayout.maxSize)
						
						targetFrame.origin.x = containerFrame.minX + usedSpace
						targetFrame.size.width = frameContentSize.width
						frameLayout.frame = targetFrame
						
						if frameLayout.isEmpty { continue }
						
						gapSpace = frameContentSize.width > 0 ? spacing : 0
						usedSpace += frameContentSize.width + gapSpace
						ratioIndex += 1
					}
					
					break
				
				case .center:
					if isOverlapped {
						for frameLayout in frameLayouts {
							frameContentSize = frameLayout.isFlexible ? containerFrame.size : frameLayout.sizeThatFits(containerFrame.size, ignoreHiddenView: false)
							targetFrame.size.width = frameContentSize.width
							targetFrame.size.height = containerFrame.height
							targetFrame.origin.x = containerFrame.minX + (containerFrame.width - targetFrame.width)/2
							frameLayout.frame = targetFrame
						}
						break
					}
					
					for frameLayout in frameLayouts {
						frameContentSize = containerFrame.size
						let fitSize = frameLayout.sizeThatFits(frameContentSize, ignoreHiddenView: false)
						frameContentSize.width = fitSize.width
						
						targetFrame.origin.x = containerFrame.minX + usedSpace
						targetFrame.size = frameContentSize
						frameLayout.frame = targetFrame
						
						if frameLayout.isEmpty { continue }
						
						gapSpace = frameContentSize.width > 0 && frameLayout != lastFrameLayout ? spacing : 0
						usedSpace += frameContentSize.width + gapSpace
					}
					
					let offset = (containerFrame.width - usedSpace) / 2.0
					for frameLayout in frameLayouts {
						frameLayout.frame = frameLayout.frame.offsetBy(dx: offset, dy: 0)
					}
					
					break
			}
		}
		else { // if axis == .vertical
			switch distribution {
				case .top, .left:
					if isOverlapped {
						for frameLayout in frameLayouts {
							frameContentSize = frameLayout.isFlexible ? containerFrame.size : frameLayout.sizeThatFits(containerFrame.size, ignoreHiddenView: false)
							targetFrame.origin.y = containerFrame.minY
							targetFrame.size.width = containerFrame.width
							targetFrame.size.height = frameContentSize.height
							frameLayout.frame = targetFrame
						}
						break
					}
					
					var flexibleFrames = [FrameLayout]()
					
					for frameLayout in frameLayouts {
						let isEmpty = frameLayout.isEmpty
						
						if frameLayout.isFlexible && !isEmpty {
							flexibleFrames.append(frameLayout)
							continue
						}
						
						frameContentSize = CGSize(width: containerFrame.width, height: containerFrame.height - usedSpace)
						let fitSize = frameLayout.sizeThatFits(frameContentSize, ignoreHiddenView: false)
						
						if frameLayout == lastFrameLayout && !frameLayout.isIntrinsicSizeEnabled {
							frameContentSize.width = fitSize.width
						}
						else {
							frameContentSize = fitSize
						}
						
						targetFrame.origin.y = containerFrame.minY + usedSpace
						targetFrame.size.height = frameContentSize.height
						frameLayout.frame = targetFrame
						
						if isEmpty { continue }
						
						gapSpace = frameContentSize.height > 0 ? spacing : 0
						usedSpace += frameContentSize.height + gapSpace
					}
					
					let flexibleFrameCount = flexibleFrames.count
					if flexibleFrameCount > 0 {
						let remainingSpace = CGFloat(flexibleFrameCount - 1) * spacing
						let contentHeight = containerFrame.height - usedSpace - remainingSpace
						let ratio = flexibleFrames.map { $0.flexibleRatio }.autoFill(total: flexibleFrameCount)
						
						gapSpace = 0
						var ratioIndex = 0
						var offset = edgeInsets.top
						for frameLayout in frameLayouts {
							var rect = frameLayout.frame
							let isEmpty = frameLayout.isEmpty
							
							if frameLayout.isFlexible && !isEmpty {
								let ratioValue = ratio[ratioIndex]
								let cellHeight = contentHeight * ratioValue
								
								rect = targetFrame
								rect.size = CGSize(width: containerFrame.width, height: cellHeight).limitTo(minSize: frameLayout.minSize, maxSize: frameLayout.maxSize)
								ratioIndex += 1
							}
							
							if rect.minY != offset || frameLayout.frame.size != rect.size {
								rect.origin.y = offset
								frameLayout.frame = rect
							}
							
							if isEmpty { continue }
							
							gapSpace = rect.height > 0 ? spacing : 0
							offset += rect.height + gapSpace
						}
					}
					else if isJustified {
						let remainingHeight = containerFrame.height - usedSpace
						let numberOfSpaces = numberOfVisibleFrames() - 1
						
						if remainingHeight > justifyThreshold, numberOfSpaces > 0 {
							let spaces = CGFloat(numberOfSpaces)
							let extraValuePerSpace = (remainingHeight / spaces) + (spacing / spaces)
							let firstFrame = frameLayouts.first(where: { !$0.isEmpty })
							
							var index = 1
							for frameLayout in frameLayouts {
								if frameLayout == firstFrame { continue }
								var rect = frameLayout.frame
								rect.origin.y += extraValuePerSpace * CGFloat(index)
								frameLayout.frame = rect
								if !frameLayout.isEmpty { index += 1 }
							}
						}
					}
					break
				
				case .bottom, .right:
					if isOverlapped {
						for frameLayout in frameLayouts {
							frameContentSize = frameLayout.isFlexible ? containerFrame.size : frameLayout.sizeThatFits(containerFrame.size, ignoreHiddenView: false)
							targetFrame.size.width = containerFrame.width
							targetFrame.size.height = frameContentSize.height
							targetFrame.origin.y = containerFrame.minY + (containerFrame.height - targetFrame.height)
							frameLayout.frame = targetFrame
						}
						break
					}
					
					var flexibleFrames = [FrameLayout]()
					
					for frameLayout in invertedLayoutArray {
						let isEmpty = frameLayout.isEmpty
						
						if frameLayout.isFlexible && !isEmpty {
							flexibleFrames.append(frameLayout)
							continue
						}
						
						if frameLayout == lastFrameLayout && !frameLayout.isIntrinsicSizeEnabled {
							targetFrame.origin.y = edgeInsets.top
							targetFrame.size.height = containerFrame.height - usedSpace
						}
						else {
							frameContentSize = CGSize(width: containerFrame.width, height: containerFrame.height - usedSpace)
							frameContentSize = frameLayout.sizeThatFits(frameContentSize, ignoreHiddenView: false)
							
							targetFrame.origin.y = max(bounds.height - frameContentSize.height - edgeInsets.bottom - usedSpace, 0)
							targetFrame.size.height = frameContentSize.height
						}
						
						frameLayout.frame = targetFrame
						
						if isEmpty { continue }
						
						gapSpace = frameContentSize.height > 0 ? spacing : 0
						usedSpace += frameContentSize.height + gapSpace
					}
					
					let flexibleFrameCount = flexibleFrames.count
					if flexibleFrameCount > 0 {
						let remainingSpace = CGFloat(flexibleFrameCount - 1) * spacing
						let contentHeight = containerFrame.height - usedSpace - remainingSpace
						let ratio = flexibleFrames.map { $0.flexibleRatio }.autoFill(total: flexibleFrameCount)
						
						gapSpace = 0
						var ratioIndex = 0
						var offset = containerFrame.maxY
						for frameLayout in invertedLayoutArray {
							var rect = frameLayout.frame
							let isEmpty = frameLayout.isEmpty
							
							if frameLayout.isFlexible && !isEmpty {
								let ratioValue = ratio[ratioIndex]
								let cellHeight = contentHeight * ratioValue
								
								rect = targetFrame
								rect.size = CGSize(width: containerFrame.width, height: cellHeight).limitTo(minSize: frameLayout.minSize, maxSize: frameLayout.maxSize)
								ratioIndex += 1
							}
							
							if isEmpty { continue }
							
							offset -= rect.height + gapSpace
							
							if rect.minY != offset || frameLayout.frame.size != rect.size {
								rect.origin.y = offset
								frameLayout.frame = rect
							}
							
							gapSpace = rect.height > 0 ? spacing : 0
						}
					}
					else if isJustified {
						let remainingHeight = containerFrame.height - usedSpace
						let numberOfSpaces = numberOfVisibleFrames() - 1
						
						if remainingHeight > justifyThreshold, numberOfSpaces > 0 {
							let spaces = CGFloat(numberOfSpaces)
							let extraValuePerSpace = (remainingHeight / spaces) + (spacing / spaces)
							let firstFrame = frameLayouts.first(where: { !$0.isEmpty })
							
							var index = 1
							for frameLayout in frameLayouts {
								if frameLayout == firstFrame { continue }
								var rect = frameLayout.frame
								rect.origin.y -= extraValuePerSpace * CGFloat(index)
								frameLayout.frame = rect
								if !frameLayout.isEmpty { index += 1 }
							}
						}
					}
					break
				
				case .equal:
					if isOverlapped {
						for frameLayout in frameLayouts {
							frameLayout.frame = containerFrame
						}
						break
					}
					
					let visibleFrameLayouts = visibleFrames()
					let visibleFrameCount = visibleFrameLayouts.count
					let spaces = CGFloat(visibleFrameCount - 1) * spacing
					let cellSize = (containerFrame.height - spaces) / CGFloat(Float(visibleFrameCount))
					
					for frameLayout in frameLayouts {
						frameContentSize = CGSize(width: containerFrame.width, height: cellSize)
						//if frameLayout.isIntrinsicSizeEnabled frameContentSize = frameLayout.sizeThatFits(frameContentSize, ignoreHiddenView: false)
						
						targetFrame.origin.y = containerFrame.minY + usedSpace
						targetFrame.size.height = frameContentSize.height
						frameLayout.frame = targetFrame
						
						if frameLayout.isEmpty { continue }
						
						usedSpace += frameContentSize.height + spacing
					}
					break
				
				case .center:
					if isOverlapped {
						for frameLayout in frameLayouts {
							frameContentSize = frameLayout.isFlexible ? containerFrame.size : frameLayout.sizeThatFits(containerFrame.size, ignoreHiddenView: false)
							targetFrame.size.width = containerFrame.width
							targetFrame.size.height = frameContentSize.height
							targetFrame.origin.y = containerFrame.minY + (containerFrame.height - targetFrame.width)/2
							frameLayout.frame = targetFrame
						}
						break
					}
					
					for frameLayout in frameLayouts {
						frameContentSize = containerFrame.size
						let fitSize = frameLayout.sizeThatFits(frameContentSize, ignoreHiddenView: false)
						frameContentSize.height = fitSize.height
						
						targetFrame.origin.y = containerFrame.minY + usedSpace
						targetFrame.size = frameContentSize
						frameLayout.frame = targetFrame
						
						if frameLayout.isEmpty { continue }
						
						gapSpace = frameContentSize.height > 0 && frameLayout != lastFrameLayout ? spacing : 0
						usedSpace += frameContentSize.height + gapSpace
					}
					
					let offset = (containerFrame.height - usedSpace) / 2.0
					for frameLayout in frameLayouts {
						frameLayout.frame = frameLayout.frame.offsetBy(dx: 0, dy: offset)
					}
					break
				
				case .split(let ratio):
					let visibleFrameLayouts = visibleFrames()
					let visibleFrameCount = visibleFrameLayouts.count
					let spaces = CGFloat(visibleFrameCount - 1) * spacing
					let contentHeight = containerFrame.height - spaces
					
					if isOverlapped {
						for frameLayout in frameLayouts {
							frameContentSize = frameLayout.isFlexible ? containerFrame.size : frameLayout.sizeThatFits(containerFrame.size, ignoreHiddenView: false).limitTo(minSize: frameLayout.minSize, maxSize: frameLayout.maxSize)
							targetFrame.origin.y = containerFrame.minY
							targetFrame.size.width = containerFrame.width
							targetFrame.size.height = frameContentSize.height
							frameLayout.frame = targetFrame
						}
						break
					}
					
					let finalRatio = ratio.autoFill(total: visibleFrameCount)
					
					var ratioIndex = 0
					for frameLayout in frameLayouts {
						let ratioValue = finalRatio[ratioIndex]
						let cellHeight = contentHeight * ratioValue
						frameContentSize = CGSize(width: containerFrame.width, height: cellHeight).limitTo(minSize: frameLayout.minSize, maxSize: frameLayout.maxSize)
						
						targetFrame.origin.y = containerFrame.minY + usedSpace
						targetFrame.size.height = frameContentSize.height
						frameLayout.frame = targetFrame
						
						if frameLayout.isEmpty { continue }
						
						gapSpace = frameContentSize.height > 0 ? spacing : 0
						usedSpace += frameContentSize.height + gapSpace
						ratioIndex += 1
					}
					break
			}
		}
		
		if translationX != 0 || translationY != 0 {
			frameLayouts.forEach {
				$0.frame = $0.frame.offsetBy(dx: translationOffset.x, dy: translationOffset.y)
			}
		}
	}
	
}


// MARK: -

fileprivate extension Array where Element == CGFloat {
	
	/// convert [0.2, -1, -1, 0.3] to [0.2, 0.25, 0.25, 0.3] so total value in array equal to 1.0
	
	func autoFill(total: Int) -> [CGFloat] {
		var finalRatio = self
		let gapCount = total - count
		if gapCount > 0 {
			finalRatio.append(contentsOf: [CGFloat](repeating: -1, count: gapCount)) // fill in missing value as -1
		}
		
		let flexibleRatioCount = finalRatio.filter( { $0 < 0.0 }).count
		if flexibleRatioCount > 0 {
			let remainingRatio = Swift.max(1.0 - (self.filter( {$0 > -1}).reduce(0, +)), 0.0) / CGFloat(flexibleRatioCount)
			finalRatio = finalRatio.replacingMultipleOccurrences(using: (of: -1, with: remainingRatio))
		}
		
		return finalRatio
	}
	
}

// MARK: - HStackLayout

open class HStackLayout: StackFrameLayout {
	
	@discardableResult
	public init(_ block: (HStackLayout) throws -> Void) rethrows {
		super.init()
		axis = .horizontal
		try block(self)
	}
	
	required public init() {
		super.init()
		axis = .horizontal
	}
	
	required public init?(coder aDecoder: NSCoder) {
		fatalError("init(coder:) has not been implemented")
	}
	
}

// MARK: - VStackLayout

open class VStackLayout: StackFrameLayout {
	
	@discardableResult
	public init(_ block: (VStackLayout) throws -> Void) rethrows {
		super.init()
		axis = .vertical
		try block(self)
	}
	
	required public init() {
		super.init()
		axis = .vertical
	}
	
	required public init?(coder aDecoder: NSCoder) {
		fatalError("init(coder:) has not been implemented")
	}
	
}

// MARK: - ZStackLayout

open class ZStackLayout: StackFrameLayout {
	
	@discardableResult
	public init(_ block: (ZStackLayout) throws -> Void) rethrows {
		super.init()
		axis = .vertical
		isOverlapped = true
		try block(self)
	}
	
	required public init() {
		super.init()
		axis = .vertical
		isOverlapped = true
	}
	
	required public init?(coder aDecoder: NSCoder) {
		fatalError("init(coder:) has not been implemented")
	}
	
	open override func add(_ view: UIView? = nil) -> FrameLayout {
		return super.add(view).flexible()
	}
	
}



================================================
FILE: FrameLayoutKit/Classes/.gitkeep
================================================



================================================
FILE: FrameLayoutKit/Classes/Extensions/DoubleFrameLayout+Chainable.swift
================================================
//
//  DoubleFrameLayout+Chainable.swift
//  FrameLayoutKit
//
//  Created by Nam Kennic on 9/12/21.
//

import Foundation
import UIKit

extension DoubleFrameLayout {
	
	@discardableResult public func axis(_ value: NKLayoutAxis) -> Self {
		axis = value
		return self
	}
	
	@discardableResult public func spacing(_ value: CGFloat) -> Self {
		spacing = value
		return self
	}
	
	@discardableResult public func distribution(_ value: NKLayoutDistribution) -> Self {
		distribution = value
		return self
	}
	
	@discardableResult public func overlapped(_ value: Bool) -> Self {
		isOverlapped = value
		return self
	}
	
	@discardableResult public func leftView(_ view: UIView?) -> Self {
		setLeft(view)
		return self
	}
	
	@discardableResult public func rightView(_ view: UIView?) -> Self {
		setRight(view)
		return self
	}
	
}



================================================
FILE: FrameLayoutKit/Classes/Extensions/FlowFrameLayout+Chainable.swift
================================================
//
//  FlowFrameLayout+Chainable.swift
//  FrameLayoutKit
//
//  Created by Nam Kennic on 9/12/21.
//

import Foundation
import UIKit

extension FlowFrameLayout {
	
	@discardableResult public func axis(_ value: NKLayoutAxis) -> Self {
		axis = value
		return self
	}
	
	@discardableResult public func distribution(_ value: NKLayoutDistribution) -> Self {
		distribution = value
		return self
	}
	
	@discardableResult public func justified(_ value: Bool) -> Self {
		isJustified = value
		return self
	}
	
	@discardableResult public func interitemSpacing(_ value: CGFloat) -> Self {
		interItemSpacing = value
		return self
	}
	
	@discardableResult public func lineSpacing(_ value: CGFloat) -> Self {
		lineSpacing = value
		return self
	}
	
	@discardableResult public func intrinsicSizeEnabled(_ value: Bool) -> Self {
		isIntrinsicSizeEnabled = value
		return self
	}
	
}




================================================
FILE: FrameLayoutKit/Classes/Extensions/FrameLayout+Chainable.swift
================================================
//
//  FrameLayout+Chainable.swift
//  FrameLayoutKit
//
//  Created by Nam Kennic on 9/12/21.
//

import Foundation
import UIKit

/**
Supports chaining syntax:

frameLayout
 .flexible()
 .align(vertical: .center, horizontal: .left)
 .padding(top: 10, bottom: 20)
 .minHeight(100)
*/

extension FrameLayout {
	
	@discardableResult public func flexible(ratio: CGFloat = -1) -> Self {
		isFlexible = true
		flexibleRatio = ratio
		return self
	}
	
	@discardableResult public func inflexible() -> Self {
		isFlexible = false
		return self
	}
	
	@discardableResult public func padding(top: CGFloat = 0, left: CGFloat = 0, bottom: CGFloat = 0, right: CGFloat = 0) -> Self {
		edgeInsets = UIEdgeInsets(top: top, left: left, bottom: bottom, right: right)
		return self
	}
	
	@discardableResult public func padding(_ value: CGFloat) -> Self {
		edgeInsets = UIEdgeInsets(top: value, left: value, bottom: value, right: value)
		return self
	}
	
	@discardableResult public func addPadding(top: CGFloat = 0, left: CGFloat = 0, bottom: CGFloat = 0, right: CGFloat = 0) -> Self {
		edgeInsets = UIEdgeInsets(top: edgeInsets.top + top, left: edgeInsets.left + left, bottom: edgeInsets.bottom + bottom, right: edgeInsets.right + right)
		return self
	}
	
	@discardableResult public func align(vertical: NKContentVerticalAlignment? = nil, horizontal: NKContentHorizontalAlignment? = nil) -> Self {
		alignment = (vertical ?? alignment.vertical, horizontal ?? alignment.horizontal)
		return self
	}
	
	@discardableResult public func aligns(_ vertical: NKContentVerticalAlignment, _ horizontal: NKContentHorizontalAlignment) -> Self {
		alignment = (vertical, horizontal)
		return self
	}
	
	@discardableResult public func extends(size: CGSize) -> Self {
		extendSize = size
		return self
	}
	
	@discardableResult public func extends(width: CGFloat) -> Self {
		extendSize.width = width
		return self
	}
	
	@discardableResult public func extends(height: CGFloat) -> Self {
		extendSize.height = height
		return self
	}
	
	@discardableResult public func fixedSize(_ value: CGSize) -> Self {
		fixedSize = value
		return self
	}
	
	@discardableResult public func fixedHeight(_ value: CGFloat) -> Self {
		fixedHeight = value
		return self
	}
	
	@discardableResult public func fixedWidth(_ value: CGFloat) -> Self {
		fixedWidth = value
		return self
	}
	
	@discardableResult public func minSize(_ value: CGSize) -> Self {
		minSize = value
		return self
	}
	
	@discardableResult public func maxSize(_ value: CGSize) -> Self {
		maxSize = value
		return self
	}
	
	@discardableResult public func minWidth(_ value: CGFloat) -> Self {
		minWidth = value
		return self
	}
	
	@discardableResult public func maxWidth(_ value: CGFloat) -> Self {
		maxWidth = value
		return self
	}
	
	@discardableResult public func maxHeight(_ value: CGFloat) -> Self {
		maxHeight = value
		return self
	}
	
	@discardableResult public func minHeight(_ value: CGFloat) -> Self {
		minHeight = value
		return self
	}
	
	@discardableResult public func fixedContentSize(_ value: CGSize) -> Self {
		fixedContentSize = value
		return self
	}
	
	@discardableResult public func fixedContentWidth(_ value: CGFloat) -> Self {
		fixedContentWidth = value
		return self
	}
	
	@discardableResult public func fixedContentHeight(_ value: CGFloat) -> Self {
		fixedContentHeight = value
		return self
	}
	
	@discardableResult public func maxContentSize(_ value: CGSize) -> Self {
		maxContentSize = value
		return self
	}
	
	@discardableResult public func minContentSize(_ value: CGSize) -> Self {
		minContentSize = value
		return self
	}
	
	@discardableResult public func maxContentWidth(_ value: CGFloat) -> Self {
		maxContentWidth = value
		return self
	}
	
	@discardableResult public func maxContentHeight(_ value: CGFloat) -> Self {
		maxContentHeight = value
		return self
	}
	
	@discardableResult public func minContentWidth(_ value: CGFloat) -> Self {
		minContentWidth = value
		return self
	}
	
	@discardableResult public func minContentHeight(_ value: CGFloat) -> Self {
		minContentHeight = value
		return self
	}
	
	@discardableResult public func heightRatio(_ value: CGFloat) -> Self {
		heightRatio = value
		return self
	}
	
	@discardableResult public func translationOffset(_ value: CGPoint) -> Self {
		translationOffset = value
		return self
	}
	
	@discardableResult public func translationX(_ value: CGFloat) -> Self {
		translationX = value
		return self
	}
	
	@discardableResult public func translationY(_ value: CGFloat) -> Self {
		translationY = value
		return self
	}
	
	@discardableResult public func lazyBindFrame(to: @escaping (() -> UIView?)) -> Self {
		lazyBindingViews = { [to()] }
		return self
	}
	
	@discardableResult public func lazyBindFrame(to: @escaping (() -> [UIView?])) -> Self {
		lazyBindingViews = to
		return self
	}
	
	@discardableResult public func bindFrame(to views: UIView ...) -> Self {
		if let bindingViews, !bindingViews.isEmpty {
			self.bindingViews?.append(contentsOf: views)
		}
		else {
			bindingViews = views
		}
		return self
	}
	
	@discardableResult public func bindingEdgeInsets(_ value: UIEdgeInsets) -> Self {
		bindingEdgeInsets = value
		return self
	}
	
	@discardableResult public func assign(to instance: inout FrameLayout?) -> Self {
		instance = self
		return self
	}
	
	@discardableResult public func enable(_ value: Bool) -> Self {
		isEnabled = value
		return self
	}
	
	@discardableResult public func debug(_ value: Bool) -> Self {
		debug = value
		return self
	}
	
	@discardableResult public func debugColor(_ value: UIColor) -> Self {
		debugColor = value
		return self
	}
	
	@discardableResult public func contentVerticalGrowing(_ value: Bool) -> Self {
		allowContentVerticalGrowing = value
		return self
	}
	
	@discardableResult public func contentVerticalShrinking(_ value: Bool) -> Self {
		allowContentVerticalShrinking = value
		return self
	}
	
	@discardableResult public func contentHorizontalGrowing(_ value: Bool) -> Self {
		allowContentHorizontalGrowing = value
		return self
	}
	
	@discardableResult public func contentHorizontalShriking(_ value: Bool) -> Self {
		allowContentHorizontalShrinking = value
		return self
	}
	
	@discardableResult public func ignoreHiddenView(_ value: Bool) -> Self {
		ignoreHiddenView = value
		return self
	}
	
	@discardableResult public func isIntrinsicSizeEnabled(_ value: Bool) -> Self {
		isIntrinsicSizeEnabled = value
		return self
	}
	
	@discardableResult public func isFlexible(_ value: Bool) -> Self {
		isFlexible = value
		return self
	}
	
	@discardableResult public func willLayoutSubviews(_ block: @escaping (FrameLayout) -> Void) -> Self {
		willLayoutSubviewsBlock = block
		return self
	}
	
	@discardableResult public func didLayoutSubviews(_ block: @escaping (FrameLayout) -> Void) -> Self {
		didLayoutSubviewsBlock = block
		return self
	}
	
	@discardableResult public func willSizeThatFits(_ block: @escaping (FrameLayout, CGSize) -> Void) -> Self {
		willSizeThatFitsBlock = block
		return self
	}
	
	// UIView properties
	
	@discardableResult public func backgroundColor(_ color: UIColor) -> Self {
		backgroundColor = color
		return self
	}
	
	@discardableResult public func alpha(_ value: CGFloat) -> Self {
		alpha = value
		return self
	}
	
	@discardableResult public func clipsToBounds(_ value: Bool) -> Self {
		clipsToBounds = value
		return self
	}
	
	@discardableResult public func isUserInteractionEnabled(_ value: Bool) -> Self {
		isUserInteractionEnabled = value
		return self
	}
	
	// Skeleton
	
	@discardableResult public func isSkeletonMode(_ value: Bool) -> Self {
		isSkeletonMode = value
		return self
	}
	
	@discardableResult public func skeletonColor(_ value: UIColor) -> Self {
		skeletonColor = value
		return self
	}
	
	@discardableResult public func skeletonMinSize(_ value: CGSize) -> Self {
		skeletonMinSize = value
		return self
	}
	
	@discardableResult public func skeletonMaxSize(_ value: CGSize) -> Self {
		skeletonMaxSize = value
		return self
	}
	
}



================================================
FILE: FrameLayoutKit/Classes/Extensions/FrameLayout+Extension.swift
================================================
//
//  FrameLayout+Extension.swift
//  FrameLayoutKit
//
//  Created by Nam Kennic on 4/28/20.
//  Copyright © 2020 Nam Kennic. All rights reserved.
//

import Foundation
import UIKit

public extension FrameLayout {
	
	@discardableResult
	static func +(lhs: FrameLayout, rhs: UIView? = nil) -> FrameLayout {
		lhs.targetView = rhs
		return lhs
	}
}

infix operator ---

public extension StackFrameLayout {
	
	@discardableResult
	static func ---(lhs: StackFrameLayout, _ size: CGFloat = 0) -> FrameLayout {
		return lhs.addSpace(size)
	}
	
	@discardableResult
	static func +(lhs: StackFrameLayout, rhs: UIView? = nil) -> FrameLayout {
		return lhs.add(rhs)
	}
	
	@discardableResult
	static func +(lhs: StackFrameLayout, rhs: [UIView]? = nil) -> [FrameLayout] {
		var results = [FrameLayout]()
		rhs?.forEach { results.append(lhs.add($0)) }
		return results
	}
	
	@discardableResult
	static func +(lhs: StackFrameLayout, rhs: CGFloat = 0) -> FrameLayout {
		return lhs.addSpace(rhs)
	}
	
	@discardableResult
	static func +(lhs: StackFrameLayout, rhs: Double = 0) -> FrameLayout {
		return lhs.addSpace(CGFloat(rhs))
	}
	
	@discardableResult
	static func +(lhs: StackFrameLayout, rhs: Int = 0) -> FrameLayout {
		return lhs.addSpace(CGFloat(rhs))
	}
	
}

public extension ScrollStackView {
	
	@discardableResult
	static func ---(lhs: ScrollStackView, _ size: CGFloat = 0) -> FrameLayout {
		return lhs.addSpace(size)
	}
	
	@discardableResult
	static func +(lhs: ScrollStackView, rhs: UIView? = nil) -> FrameLayout {
		return lhs.add(rhs)
	}
	
	@discardableResult
	static func +(lhs: ScrollStackView, rhs: [UIView]? = nil) -> [FrameLayout] {
		var results = [FrameLayout]()
		rhs?.forEach { results.append(lhs.add($0)) }
		return results
	}
	
	@discardableResult
	static func +(lhs: ScrollStackView, rhs: CGFloat = 0) -> FrameLayout {
		return lhs.addSpace(rhs)
	}
	
	@discardableResult
	static func +(lhs: ScrollStackView, rhs: Double = 0) -> FrameLayout {
		return lhs.addSpace(CGFloat(rhs))
	}
	
	@discardableResult
	static func +(lhs: ScrollStackView, rhs: Int = 0) -> FrameLayout {
		return lhs.addSpace(CGFloat(rhs))
	}
	
}

infix operator <+ // frameLayout <+ label
infix operator +> // frameLayout +> imageView

public extension DoubleFrameLayout {
	
	@discardableResult
	static func <+(lhs: DoubleFrameLayout, rhs: UIView? = nil) -> FrameLayout {
		if let frameLayout = rhs as? FrameLayout, frameLayout.superview == nil {
			lhs.leftFrameLayout = frameLayout
		}
		else {
			lhs.leftFrameLayout.targetView = rhs
		}
		
		return lhs.leftFrameLayout
	}
	
	@discardableResult
	static func +>(lhs: DoubleFrameLayout, rhs: UIView? = nil) -> FrameLayout {
		if let frameLayout = rhs as? FrameLayout, frameLayout.superview == nil {
			lhs.rightFrameLayout = frameLayout
		}
		else {
			lhs.rightFrameLayout.targetView = rhs
		}
		
		return lhs.rightFrameLayout
	}
	
}

// MARK: -

open class StackLayout: StackFrameLayout {
	
	@discardableResult
	public init(_ block: (StackLayout) throws -> Void) rethrows {
		super.init()
		try block(self)
	}
	
	required public init?(coder aDecoder: NSCoder) {
		fatalError("init(coder:) has not been implemented")
	}
	
	public required init() {
		fatalError("init() has not been implemented")
	}
	
}

public extension FlowFrameLayout {
	
	@discardableResult
	static func +(lhs: FlowFrameLayout, rhs: UIView) -> UIView {
		return lhs.add(rhs)
	}
}

extension CGSize {
	
	mutating func limitedTo(minSize: CGSize, maxSize: CGSize) {
		self = self.limitTo(minSize: minSize, maxSize: maxSize)
	}
	
	func limitTo(minSize: CGSize, maxSize: CGSize) -> CGSize {
		var result = self
		
		result.width = max(minSize.width, result.width)
		result.height = max(minSize.height, result.height)
		
		if maxSize.width > 0 && maxSize.width >= minSize.width {
			result.width = min(maxSize.width, result.width)
		}
		if maxSize.height > 0 && maxSize.height >= minSize.height {
			result.height = min(maxSize.height, result.height)
		}
		
		return result
	}
	
}

internal extension Array where Element: Equatable {
	
	func replacingMultipleOccurrences(using array: (of: Element, with: Element)...) -> Array {
		return map { elem in array.first(where: { $0.of == elem })?.with ?? elem }
	}
	
}



================================================
FILE: FrameLayoutKit/Classes/Extensions/GridFrameLayout+Chainable.swift
================================================
//
//  GridFrameLayout+Chainable.swift
//  FrameLayoutKit
//
//  Created by Nam Kennic on 9/12/21.
//

import Foundation
import UIKit

extension GridFrameLayout {
	
	@discardableResult public func axis(_ value: NKLayoutAxis) -> Self {
		axis = value
		return self
	}
	
	@discardableResult public func minRowHeight(_ value: CGFloat) -> Self {
		minRowHeight = value
		return self
	}
	
	@discardableResult public func maxRowHeight(_ value: CGFloat) -> Self {
		maxRowHeight = value
		return self
	}
	
	@discardableResult public func minColumnWidth(_ value: CGFloat) -> Self {
		minColumnWidth = value
		return self
	}
	
	@discardableResult public func maxColumnWidth(_ value: CGFloat) -> Self {
		maxColumnWidth = value
		return self
	}
	
	@discardableResult public func fixedRowHeight(_ value: CGFloat) -> Self {
		fixedRowHeight = value
		return self
	}
	
	@discardableResult public func fixedColumnWidth(_ value: CGFloat) -> Self {
		fixedColumnWidth = value
		return self
	}
	
	@discardableResult public func interitemSpacing(_ value: CGFloat) -> Self {
		verticalSpacing = value
		return self
	}
	
	@discardableResult public func lineSpacing(_ value: CGFloat) -> Self {
		horizontalSpacing = value
		return self
	}
	
}



================================================
FILE: FrameLayoutKit/Classes/Extensions/ScrollStackView+Chainable.swift
================================================
//
//  ScrollStackView+Chainable.swift
//  FrameLayoutKit
//
//  Created by Nam Kennic on 9/12/21.
//

import Foundation
import UIKit

extension ScrollStackView {
	
	@discardableResult public func axis(_ value: NKLayoutAxis) -> Self {
		axis = value
		return self
	}
	
	@discardableResult public func spacing(_ value: CGFloat) -> Self {
		spacing = value
		return self
	}
	
	@discardableResult public func padding(_ value: CGFloat) -> Self {
		edgeInsets = UIEdgeInsets(top: value, left: value, bottom: value, right: value)
		return self
	}
	
	@discardableResult public func distribution(_ value: NKLayoutDistribution) -> Self {
		distribution = value
		return self
	}
	
	@discardableResult public func directionalLock(_ value: Bool) -> Self {
		isDirectionalLockEnabled = value
		return self
	}
	
	@discardableResult public func extends(size: CGSize) -> Self {
		extendSize = size
		return self
	}
	
	@discardableResult public func extends(width: CGFloat) -> Self {
		extendSize.width = width
		return self
	}
	
	@discardableResult public func extends(height: CGFloat) -> Self {
		extendSize.height = height
		return self
	}
	
	@discardableResult public func fixedSize(_ value: CGSize) -> Self {
		fixedSize = value
		return self
	}
	
	@discardableResult public func fixedHeight(_ value: CGFloat) -> Self {
		fixedHeight = value
		return self
	}
	
	@discardableResult public func fixedWidth(_ value: CGFloat) -> Self {
		fixedWidth = value
		return self
	}
	
	@discardableResult public func minSize(_ value: CGSize) -> Self {
		minSize = value
		return self
	}
	
	@discardableResult public func maxSize(_ value: CGSize) -> Self {
		maxSize = value
		return self
	}
	
	@discardableResult public func minWidth(_ value: CGFloat) -> Self {
		minWidth = value
		return self
	}
	
	@discardableResult public func maxWidth(_ value: CGFloat) -> Self {
		maxWidth = value
		return self
	}
	
	@discardableResult public func maxHeight(_ value: CGFloat) -> Self {
		maxHeight = value
		return self
	}
	
	@discardableResult public func minHeight(_ value: CGFloat) -> Self {
		minHeight = value
		return self
	}
	
	@discardableResult public func fixedContentSize(_ value: CGSize) -> Self {
		fixedContentSize = value
		return self
	}
	
	@discardableResult public func fixedContentWidth(_ value: CGFloat) -> Self {
		fixedContentWidth = value
		return self
	}
	
	@discardableResult public func fixedContentHeight(_ value: CGFloat) -> Self {
		fixedContentHeight = value
		return self
	}
	
	@discardableResult public func maxContentSize(_ value: CGSize) -> Self {
		maxContentSize = value
		return self
	}
	
	@discardableResult public func minContentSize(_ value: CGSize) -> Self {
		minContentSize = value
		return self
	}
	
	@discardableResult public func maxContentWidth(_ value: CGFloat) -> Self {
		maxContentWidth = value
		return self
	}
	
	@discardableResult public func maxContentHeight(_ value: CGFloat) -> Self {
		maxContentHeight = value
		return self
	}
	
	@discardableResult public func minContentWidth(_ value: CGFloat) -> Self {
		minContentWidth = value
		return self
	}
	
	@discardableResult public func minContentHeight(_ value: CGFloat) -> Self {
		minContentHeight = value
		return self
	}
	
	@discardableResult public func contentFitSize(_ value: CGSize) -> Self {
		contentFitSize = value
		return self
	}
	
	@discardableResult public func heightRatio(_ value: CGFloat) -> Self {
		heightRatio = value
		return self
	}
	
	@discardableResult public func flexible(_ value: Bool) -> Self {
		isFlexible = value
		return self
	}
	
	@discardableResult public func overlapped(_ value: Bool) -> Self {
		isOverlapped = value
		return self
	}
	
	@discardableResult public func minItemSize(_ value: CGSize) -> Self {
		minItemSize = value
		return self
	}
	
	@discardableResult public func maxItemSize(_ value: CGSize) -> Self {
		maxItemSize = value
		return self
	}
	
	@discardableResult public func fixedItemSize(_ value: CGSize) -> Self {
		fixedItemSize = value
		return self
	}
	
	@discardableResult public func debug(_ value: Bool) -> Self {
		debug = value
		return self
	}
	
	@discardableResult public func debugColor(_ value: UIColor) -> Self {
		debugColor = value
		return self
	}
	
	@discardableResult public func enable(_ value: Bool) -> Self {
		isEnabled = value
		return self
	}
	
	@discardableResult public func willLayoutSubviews(_ block: @escaping (ScrollStackView) -> Void) -> Self {
		willLayoutSubviewsBlock = block
		return self
	}
	
	@discardableResult public func didLayoutSubviews(_ block: @escaping (ScrollStackView) -> Void) -> Self {
		didLayoutSubviewsBlock = block
		return self
	}
	
	@discardableResult public func willSizeThatFits(_ block: @escaping (ScrollStackView, CGSize) -> Void) -> Self {
		willSizeThatFitsBlock = block
		return self
	}
	
	@discardableResult public func isIntrinsicSizeEnabled(_ value: Bool) -> Self {
		isIntrinsicSizeEnabled = value
		return self
	}
	
	// UIView properties
	
	@discardableResult public func backgroundColor(_ color: UIColor) -> Self {
		backgroundColor = color
		return self
	}
	
	@discardableResult public func alpha(_ value: CGFloat) -> Self {
		alpha = value
		return self
	}
	
	@discardableResult public func clipsToBounds(_ value: Bool) -> Self {
		clipsToBounds = value
		return self
	}
	
	@discardableResult public func isUserInteractionEnabled(_ value: Bool) -> Self {
		isUserInteractionEnabled = value
		return self
	}
	
	@discardableResult public func each(_ block: (FrameLayout, Int, inout Bool) -> Void) -> Self {
		enumerate(block)
		return self
	}
	
	// Skeleton
	
	@discardableResult public func isSkeletonMode(_ value: Bool) -> Self {
		isSkeletonMode = value
		return self
	}
	
	@discardableResult public func skeletonColor(_ value: UIColor) -> Self {
		skeletonColor = value
		return self
	}
	
	@discardableResult public func skeletonMinSize(_ value: CGSize) -> Self {
		skeletonMinSize = value
		return self
	}
	
	@discardableResult public func skeletonMaxSize(_ value: CGSize) -> Self {
		skeletonMaxSize = value
		return self
	}
	
}



================================================
FILE: FrameLayoutKit/Classes/Extensions/StackFrameLayout+Chainable.swift
================================================
//
//  StackFrameLayout+Chainable.swift
//  FrameLayoutKit
//
//  Created by Nam Kennic on 9/12/21.
//

import Foundation
import UIKit

extension StackFrameLayout {
	
	@discardableResult public func axis(_ value: NKLayoutAxis) -> Self {
		axis = value
		return self
	}
	
	@discardableResult public func spacing(_ value: CGFloat) -> Self {
		spacing = value
		return self
	}
	
	@discardableResult public func distribution(_ value: NKLayoutDistribution) -> Self {
		distribution = value
		return self
	}
	
	@discardableResult public func overlapped(_ value: Bool) -> Self {
		isOverlapped = value
		return self
	}
	
	@discardableResult public func justified(_ value: Bool) -> Self {
		isJustified = value
		return self
	}
	
	@discardableResult public func justifyThreshold(_ value: CGFloat) -> Self {
		justifyThreshold = value
		return self
	}
	
	@discardableResult public func minItemSize(_ value: CGSize) -> Self {
		minItemSize = value
		return self
	}
	
	@discardableResult public func maxItemSize(_ value: CGSize) -> Self {
		maxItemSize = value
		return self
	}
	
	@discardableResult public func fixedItemSize(_ value: CGSize) -> Self {
		fixedItemSize = value
		return self
	}
	
	@discardableResult public func each(_ block: (FrameLayout, Int, inout Bool) -> Void) -> Self {
		enumerate(block)
		return self
	}
	
}



================================================
FILE: FrameLayoutKit/Classes/Extensions/StackFrameLayout+DSL.swift
================================================
//
//  StackFrameLayout+DSL.swift
//  FrameLayoutKit
//
//  Created by Nam Kennic on 9/25/23.
//

import UIKit

@resultBuilder
public struct FLViewBuilder {
	
	static public func buildBlock(_ views: UIView...) -> [UIView] { views }
	
}

/**
 Enable DSL syntax:
 
 ```
 let stack = HStackView {
   UILabel()
   UIButton()
 }
 */
open class HStackView: HStackLayout {
	
	public init(@FLViewBuilder builder: () -> [UIView]) {
		super.init()
		add(builder())
	}
	
	required public init?(coder: NSCoder) {
		super.init(coder: coder)
	}
	
	required public init() {
		fatalError("init() has not been implemented")
	}
	
}

/**
 Enable DSL syntax:
 
 ```
 let stack = VStackView {
   UILabel()
   UIButton()
 }
 */
open class VStackView: VStackLayout {
	
	public init(@FLViewBuilder builder: () -> [UIView]) {
		super.init()
		add(builder())
	}
	
	required public init?(coder: NSCoder) {
		super.init(coder: coder)
	}
	
	required public init() {
		fatalError("init() has not been implemented")
	}
	
}

/**
 Enable DSL syntax:
 
 ```
 let stack = ZStackView {
   UILabel()
   UIButton()
 }
 */
open class ZStackView: ZStackLayout {
	
	public init(@FLViewBuilder builder: () -> [UIView]) {
		super.init()
		add(builder())
	}
	
	required public init?(coder: NSCoder) {
		super.init(coder: coder)
	}
	
	required public init() {
		fatalError("init() has not been implemented")
	}
	
}


// MARK: -

/**
 Enable DSL syntax:
 
 ```
 let stack = VStackView {
   StackItem(label).padding(12)
   StackItem(button).aligns(.center, .center).padding(4)
 }
 */
open class StackItem<T: UIView>: FrameLayout {
	public var content: T?
	
	public required init(_ view: T?) {
		super.init()
		
		targetView = view
		content = view
	}
	
	public required init() {
		super.init()
	}
	
	public required init?(coder aDecoder: NSCoder) {
		fatalError("init(coder:) has not been implemented")
	}
	
}

// MARK: - Spacing

/**
 Enable DSL syntax:
 
 ```
 let stack = VStackView {
   StackItem(label).padding(12)
   SpaceItem(10)
   StackItem(button).aligns(.center, .center).padding(4)
 }
 */
open class SpaceItem: FrameLayout {
	
	public required init(_ value: CGFloat = 0) {
		super.init()
		minSize = CGSize(width: value, height: value)
	}
	
	public required init() {
		super.init()
	}
	
	public required init?(coder aDecoder: NSCoder) {
		fatalError("init(coder:) has not been implemented")
	}
	
}

/**
 Enable DSL syntax:
 
 ```
 let stack = VStackView {
   StackItem(label).padding(12)
   FlexibleSpace()
   StackItem(button).aligns(.center, .center).padding(4)
 }
 */
open class FlexibleSpace: FrameLayout {
	
	public required init(_ value: CGFloat = 0) {
		super.init()
		minSize = CGSize(width: value, height: value)
		flexible()
	}
	
	public required init() {
		super.init()
		flexible()
	}
	
	public required init?(coder aDecoder: NSCoder) {
		fatalError("init(coder:) has not been implemented")
	}
	
}




================================================
FILE: .swiftpm/xcode/package.xcworkspace/contents.xcworkspacedata
================================================
<?xml version="1.0" encoding="UTF-8"?>
<Workspace
   version = "1.0">
   <FileRef
      location = "self:">
   </FileRef>
</Workspace>



================================================
FILE: .swiftpm/xcode/xcuserdata/namkennic.xcuserdatad/xcschemes/xcschememanagement.plist
================================================
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>SchemeUserState</key>
	<dict>
		<key>FrameLayoutKit.xcscheme_^#shared#^_</key>
		<dict>
			<key>orderHint</key>
			<integer>0</integer>
		</dict>
	</dict>
	<key>SuppressBuildableAutocreation</key>
	<dict>
		<key>FrameLayoutKit</key>
		<dict>
			<key>primary</key>
			<true/>
		</dict>
		<key>FrameLayoutKitTests</key>
		<dict>
			<key>primary</key>
			<true/>
		</dict>
	</dict>
</dict>
</plist>

